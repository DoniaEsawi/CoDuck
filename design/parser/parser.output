Terminals unused in grammar

    LEFT_SQ_BRACKET
    RIGHT_SQ_BRACKET
    QUESTION_MARK
    DOT
    BIT_NOT_OP


State 3 conflicts: 1 shift/reduce, 8 reduce/reduce
State 5 conflicts: 1 shift/reduce, 7 reduce/reduce
State 7 conflicts: 1 reduce/reduce
State 33 conflicts: 20 shift/reduce, 8 reduce/reduce
State 39 conflicts: 1 reduce/reduce
State 40 conflicts: 1 reduce/reduce
State 59 conflicts: 1 shift/reduce, 7 reduce/reduce
State 66 conflicts: 2 shift/reduce, 4 reduce/reduce
State 101 conflicts: 20 shift/reduce, 8 reduce/reduce
State 104 conflicts: 4 reduce/reduce
State 149 conflicts: 1 reduce/reduce
State 164 conflicts: 2 shift/reduce
State 165 conflicts: 2 shift/reduce
State 166 conflicts: 2 shift/reduce
State 167 conflicts: 2 shift/reduce
State 190 conflicts: 20 shift/reduce, 8 reduce/reduce
State 191 conflicts: 1 shift/reduce
State 222 conflicts: 20 shift/reduce, 8 reduce/reduce
State 223 conflicts: 20 shift/reduce, 8 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: program function
    2        | program global
    3        | functions
    4        | globals

    5 globals: globals global
    6        | global

    7 global: declarations
    8       | enum_statement

    9 type: INTEGER
   10     | FLOAT
   11     | DOUBLE
   12     | VOID
   13     | BOOLEAN
   14     | CHAR
   15     | STR

   16 beforedecl: CONST
   17           | %empty

   18 declaration: beforedecl type IDENT SEMICOLON
   19            | beforedecl type IDENT ASSIGN_OP expression SEMICOLON

   20 $@1: %empty

   21 declarations: $@1 declaration
   22             | declarations declaration

   23 tail: LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET

   24 tail_inloop: LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET

   25 bool_expression: relExp
   26                | TRUE_TOKEN
   27                | FALSE_TOKEN

   28 assign: IDENT ASSIGN_OP expression

   29 expression: assign
   30           | IDENT INC_OP
   31           | IDENT DEC_OP
   32           | simpleExp
   33           | IDENT
   34           | bool_expression

   35 simpleExp: simpleExp OR_OP andExp
   36          | andExp

   37 andExp: andExp AND_OP
   38       | bitRelExp

   39 bitRelExp: bitRelExp BIT_OR_OP relExp
   40          | bitRelExp AND relExp
   41          | bitRelExp BIT_XOR_OP relExp
   42          | relExp

   43 op: EQ_OP
   44   | NE_OP
   45   | GT_OP
   46   | LT_OP
   47   | LE_OP
   48   | GE_OP
   49   | OR_OP
   50   | AND_OP

   51 relExp: relExp op bitshiftExp
   52       | bitshiftExp

   53 bitshiftExp: bitshiftExp BIT_LSHIFT_OP sumExp
   54            | bitshiftExp BIT_RSHIFT_OP sumExp
   55            | sumExp

   56 pls_min: ADD_OP
   57        | SUB_OP

   58 mul_div: MUL_OP
   59        | DIV_OP
   60        | MOD_OP

   61 sumExp: sumExp pls_min mulExp
   62       | mulExp

   63 mulExp: mulExp mul_div unaryExp
   64       | unaryExp

   65 unaryExp: INC_OP IDENT
   66         | DEC_OP IDENT
   67         | NOT_OP IDENT
   68         | IDENT
   69         | value
   70         | LEFT_PAREN expression RIGHT_PAREN

   71 value: CONST_INT
   72      | CONST_FLOAT
   73      | CONST_CHAR
   74      | STRING_LITERAL

   75 else_if: ELIF LEFT_PAREN bool_expression RIGHT_PAREN tail
   76        | else_if ELIF LEFT_PAREN bool_expression RIGHT_PAREN tail
   77        | %empty

   78 else_part: ELSE tail
   79          | %empty

   80 if_statement: IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part

   81 while_statement: WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop

   82 optional_type: %empty
   83              | type

   84 for_statement: FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop

   85 do_statement: DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON

   86 switch_statement: SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET

   87 cases: case
   88      | cases case
   89      | cases default

   90 default: DEFAULT COLON statements

   91 case: CASE expression COLON statements BREAK SEMICOLON

   92 return_val: expression
   93           | %empty

   94 return_statement: RETURN return_val SEMICOLON

   95 break_statement: BREAK SEMICOLON

   96 continue_statement: CONTINUE SEMICOLON

   97 expression_statement: expression SEMICOLON

   98 statements: %empty
   99           | statement
  100           | statements statement

  101 statement: if_statement
  102          | while_statement
  103          | for_statement
  104          | do_statement
  105          | switch_statement
  106          | return_statement
  107          | expression_statement
  108          | declarations
  109          | enum_statement
  110          | func_call
  111          | break_statement
  112          | continue_statement

  113 functions: functions function
  114          | function

  115 $@2: %empty

  116 function: $@2 function_head function_tail

  117 param_empty: parameters
  118            | %empty

  119 function_head: FUNC IDENT LEFT_PAREN param_empty RIGHT_PAREN type

  120 function_tail: LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET

  121 parameters: parameter
  122           | parameters COMMA parameter
  123           | %empty

  124 $@3: %empty

  125 parameter: $@3 type IDENT

  126 enum_statement: ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON

  127 enum_list: one_val
  128          | enum_list COMMA one_val

  129 one_val: IDENT
  130        | IDENT ASSIGN_OP value

  131 func_call: IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

  133 arguments: argument
  134          | arguments COMMA argument
  135          | %empty

  136 argument: expression


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    INTEGER <int_val> (258) 9
    FLOAT <int_val> (259) 10
    DOUBLE <int_val> (260) 11
    VOID <int_val> (261) 12
    BOOLEAN <int_val> (262) 13
    CHAR <int_val> (263) 14
    CONST <int_val> (264) 16
    STR <int_val> (265) 15
    IDENT <symbol_table_item> (266) 18 19 28 30 31 33 65 66 67 68 119 125 126 129 130 131 132
    CONST_INT <int_val> (267) 71
    CONST_FLOAT <double_val> (268) 72
    CONST_CHAR <char_val> (269) 73
    STRING_LITERAL <str_val> (270) 74
    IF <int_val> (271) 80
    ELSE <int_val> (272) 78
    ELIF <int_val> (273) 75 76
    WHILE <int_val> (274) 81
    FOR <int_val> (275) 84
    DO <int_val> (276) 85
    SWITCH <int_val> (277) 86
    CASE <int_val> (278) 91
    DEFAULT <int_val> (279) 90
    RETURN <int_val> (280) 94
    BREAK <int_val> (281) 91 95
    CONTINUE <int_val> (282) 96
    TRUE_TOKEN <int_val> (283) 26
    FALSE_TOKEN <int_val> (284) 27
    ENUM <int_val> (285) 126
    FUNC <int_val> (286) 119
    UNTIL <int_val> (287) 85
    LEFT_PAREN <int_val> (288) 70 75 76 80 81 84 85 86 119 131 132
    RIGHT_PAREN <int_val> (289) 70 75 76 80 81 84 85 86 119 131 132
    LEFT_CURLY_BRACKET <int_val> (290) 23 24 86 120 126
    RIGHT_CURLY_BRACKET <int_val> (291) 23 24 86 120 126
    LEFT_SQ_BRACKET <int_val> (292)
    RIGHT_SQ_BRACKET <int_val> (293)
    SEMICOLON <int_val> (294) 18 19 84 85 91 94 95 96 97 126 131 132
    COMMA <int_val> (295) 122 128 134
    COLON <int_val> (296) 90 91
    QUESTION_MARK <int_val> (297)
    DOT <int_val> (298)
    ADD_OP <int_val> (299) 56
    SUB_OP <int_val> (300) 57
    MUL_OP <int_val> (301) 58
    DIV_OP <int_val> (302) 59
    MOD_OP <int_val> (303) 60
    INC_OP <int_val> (304) 30 65
    DEC_OP <int_val> (305) 31 66
    OR_OP <int_val> (306) 35 49
    AND_OP <int_val> (307) 37 50
    NOT_OP <int_val> (308) 67
    BIT_OR_OP <int_val> (309) 39
    AND <int_val> (310) 40
    BIT_XOR_OP <int_val> (311) 41
    BIT_NOT_OP <int_val> (312)
    BIT_LSHIFT_OP <int_val> (313) 53
    BIT_RSHIFT_OP <int_val> (314) 54
    EQ_OP <int_val> (315) 43
    NE_OP <int_val> (316) 44
    GT_OP <int_val> (317) 45
    LT_OP <int_val> (318) 46
    GE_OP <int_val> (319) 48
    LE_OP <int_val> (320) 47
    ASSIGN_OP <int_val> (321) 19 28 130 132


Nonterminals, with rules where they appear

    $accept (67)
        on left: 0
    program (68)
        on left: 1 2 3 4
        on right: 0 1 2
    globals (69)
        on left: 5 6
        on right: 4 5
    global (70)
        on left: 7 8
        on right: 2 5 6
    type (71)
        on left: 9 10 11 12 13 14 15
        on right: 18 19 83 119 125
    beforedecl (72)
        on left: 16 17
        on right: 18 19
    declaration (73)
        on left: 18 19
        on right: 21 22
    declarations (74)
        on left: 21 22
        on right: 7 22 108
    $@1 (75)
        on left: 20
        on right: 21
    tail (76)
        on left: 23
        on right: 75 76 78 80
    tail_inloop (77)
        on left: 24
        on right: 81 84 85
    bool_expression (78)
        on left: 25 26 27
        on right: 34 75 76 80 81 84 85
    assign (79)
        on left: 28
        on right: 29 84
    expression (80)
        on left: 29 30 31 32 33 34
        on right: 19 28 70 84 86 91 92 97 136
    simpleExp (81)
        on left: 35 36
        on right: 32 35
    andExp (82)
        on left: 37 38
        on right: 35 36 37
    bitRelExp (83)
        on left: 39 40 41 42
        on right: 38 39 40 41
    op (84)
        on left: 43 44 45 46 47 48 49 50
        on right: 51
    relExp (85)
        on left: 51 52
        on right: 25 39 40 41 42 51
    bitshiftExp (86)
        on left: 53 54 55
        on right: 51 52 53 54
    pls_min (87)
        on left: 56 57
        on right: 61
    mul_div (88)
        on left: 58 59 60
        on right: 63
    sumExp (89)
        on left: 61 62
        on right: 53 54 55 61
    mulExp (90)
        on left: 63 64
        on right: 61 62 63
    unaryExp (91)
        on left: 65 66 67 68 69 70
        on right: 63 64
    value (92)
        on left: 71 72 73 74
        on right: 69 130
    else_if (93)
        on left: 75 76 77
        on right: 76 80
    else_part (94)
        on left: 78 79
        on right: 80
    if_statement (95)
        on left: 80
        on right: 101
    while_statement (96)
        on left: 81
        on right: 102
    optional_type (97)
        on left: 82 83
        on right: 84
    for_statement (98)
        on left: 84
        on right: 103
    do_statement (99)
        on left: 85
        on right: 104
    switch_statement (100)
        on left: 86
        on right: 105
    cases (101)
        on left: 87 88 89
        on right: 86 88 89
    default (102)
        on left: 90
        on right: 89
    case (103)
        on left: 91
        on right: 87 88
    return_val (104)
        on left: 92 93
        on right: 94
    return_statement (105)
        on left: 94
        on right: 106
    break_statement (106)
        on left: 95
        on right: 111
    continue_statement (107)
        on left: 96
        on right: 112
    expression_statement (108)
        on left: 97
        on right: 107
    statements (109)
        on left: 98 99 100
        on right: 23 24 90 91 100 120
    statement (110)
        on left: 101 102 103 104 105 106 107 108 109 110 111 112
        on right: 99 100
    functions (111)
        on left: 113 114
        on right: 3 113
    function (112)
        on left: 116
        on right: 1 113 114
    $@2 (113)
        on left: 115
        on right: 116
    param_empty (114)
        on left: 117 118
        on right: 119
    function_head (115)
        on left: 119
        on right: 116
    function_tail (116)
        on left: 120
        on right: 116
    parameters (117)
        on left: 121 122 123
        on right: 117 122
    parameter (118)
        on left: 125
        on right: 121 122
    $@3 (119)
        on left: 124
        on right: 125
    enum_statement (120)
        on left: 126
        on right: 8 109
    enum_list (121)
        on left: 127 128
        on right: 126 128
    one_val (122)
        on left: 129 130
        on right: 127 128
    func_call (123)
        on left: 131 132
        on right: 110
    arguments (124)
        on left: 133 134 135
        on right: 131 132 134
    argument (125)
        on left: 136
        on right: 133 134


State 0

    0 $accept: . program $end
    1 program: . program function
    2        | . program global
    3        | . functions
    4        | . globals
    5 globals: . globals global
    6        | . global
    7 global: . declarations
    8       | . enum_statement
   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
  113 functions: . functions function
  114          | . function
  115 $@2: . %empty  [FUNC]
  116 function: . $@2 function_head function_tail
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON

    ENUM  shift, and go to state 1

    FUNC      reduce using rule 115 ($@2)
    $default  reduce using rule 20 ($@1)

    program         go to state 2
    globals         go to state 3
    global          go to state 4
    declarations    go to state 5
    $@1             go to state 6
    functions       go to state 7
    function        go to state 8
    $@2             go to state 9
    enum_statement  go to state 10


State 1

  126 enum_statement: ENUM . IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON

    IDENT  shift, and go to state 11


State 2

    0 $accept: program . $end
    1 program: program . function
    2        | program . global
    7 global: . declarations
    8       | . enum_statement
   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
  115 $@2: . %empty  [FUNC]
  116 function: . $@2 function_head function_tail
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON

    $end  shift, and go to state 12
    ENUM  shift, and go to state 1

    FUNC      reduce using rule 115 ($@2)
    $default  reduce using rule 20 ($@1)

    global          go to state 13
    declarations    go to state 5
    $@1             go to state 6
    function        go to state 14
    $@2             go to state 9
    enum_statement  go to state 10


State 3

    4 program: globals .  [$end, INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, ENUM, FUNC]
    5 globals: globals . global
    7 global: . declarations
    8       | . enum_statement
   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON

    ENUM  shift, and go to state 1

    INTEGER   reduce using rule 4 (program)
    INTEGER   [reduce using rule 20 ($@1)]
    FLOAT     reduce using rule 4 (program)
    FLOAT     [reduce using rule 20 ($@1)]
    DOUBLE    reduce using rule 4 (program)
    DOUBLE    [reduce using rule 20 ($@1)]
    VOID      reduce using rule 4 (program)
    VOID      [reduce using rule 20 ($@1)]
    BOOLEAN   reduce using rule 4 (program)
    BOOLEAN   [reduce using rule 20 ($@1)]
    CHAR      reduce using rule 4 (program)
    CHAR      [reduce using rule 20 ($@1)]
    CONST     reduce using rule 4 (program)
    CONST     [reduce using rule 20 ($@1)]
    STR       reduce using rule 4 (program)
    STR       [reduce using rule 20 ($@1)]
    ENUM      [reduce using rule 4 (program)]
    $default  reduce using rule 4 (program)

    global          go to state 15
    declarations    go to state 5
    $@1             go to state 6
    enum_statement  go to state 10


State 4

    6 globals: global .

    $default  reduce using rule 6 (globals)


State 5

    7 global: declarations .  [$end, INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, ENUM, FUNC]
   16 beforedecl: . CONST
   17           | . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, STR]
   18 declaration: . beforedecl type IDENT SEMICOLON
   19            | . beforedecl type IDENT ASSIGN_OP expression SEMICOLON
   22 declarations: declarations . declaration

    CONST  shift, and go to state 16

    INTEGER   reduce using rule 7 (global)
    INTEGER   [reduce using rule 17 (beforedecl)]
    FLOAT     reduce using rule 7 (global)
    FLOAT     [reduce using rule 17 (beforedecl)]
    DOUBLE    reduce using rule 7 (global)
    DOUBLE    [reduce using rule 17 (beforedecl)]
    VOID      reduce using rule 7 (global)
    VOID      [reduce using rule 17 (beforedecl)]
    BOOLEAN   reduce using rule 7 (global)
    BOOLEAN   [reduce using rule 17 (beforedecl)]
    CHAR      reduce using rule 7 (global)
    CHAR      [reduce using rule 17 (beforedecl)]
    CONST     [reduce using rule 7 (global)]
    STR       reduce using rule 7 (global)
    STR       [reduce using rule 17 (beforedecl)]
    $default  reduce using rule 7 (global)

    beforedecl   go to state 17
    declaration  go to state 18


State 6

   16 beforedecl: . CONST
   17           | . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, STR]
   18 declaration: . beforedecl type IDENT SEMICOLON
   19            | . beforedecl type IDENT ASSIGN_OP expression SEMICOLON
   21 declarations: $@1 . declaration

    CONST  shift, and go to state 16

    $default  reduce using rule 17 (beforedecl)

    beforedecl   go to state 17
    declaration  go to state 19


State 7

    3 program: functions .  [$end, INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, ENUM, FUNC]
  113 functions: functions . function
  115 $@2: . %empty  [FUNC]
  116 function: . $@2 function_head function_tail

    FUNC      reduce using rule 3 (program)
    FUNC      [reduce using rule 115 ($@2)]
    $default  reduce using rule 3 (program)

    function  go to state 20
    $@2       go to state 9


State 8

  114 functions: function .

    $default  reduce using rule 114 (functions)


State 9

  116 function: $@2 . function_head function_tail
  119 function_head: . FUNC IDENT LEFT_PAREN param_empty RIGHT_PAREN type

    FUNC  shift, and go to state 21

    function_head  go to state 22


State 10

    8 global: enum_statement .

    $default  reduce using rule 8 (global)


State 11

  126 enum_statement: ENUM IDENT . LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON

    LEFT_CURLY_BRACKET  shift, and go to state 23


State 12

    0 $accept: program $end .

    $default  accept


State 13

    2 program: program global .

    $default  reduce using rule 2 (program)


State 14

    1 program: program function .

    $default  reduce using rule 1 (program)


State 15

    5 globals: globals global .

    $default  reduce using rule 5 (globals)


State 16

   16 beforedecl: CONST .

    $default  reduce using rule 16 (beforedecl)


State 17

    9 type: . INTEGER
   10     | . FLOAT
   11     | . DOUBLE
   12     | . VOID
   13     | . BOOLEAN
   14     | . CHAR
   15     | . STR
   18 declaration: beforedecl . type IDENT SEMICOLON
   19            | beforedecl . type IDENT ASSIGN_OP expression SEMICOLON

    INTEGER  shift, and go to state 24
    FLOAT    shift, and go to state 25
    DOUBLE   shift, and go to state 26
    VOID     shift, and go to state 27
    BOOLEAN  shift, and go to state 28
    CHAR     shift, and go to state 29
    STR      shift, and go to state 30

    type  go to state 31


State 18

   22 declarations: declarations declaration .

    $default  reduce using rule 22 (declarations)


State 19

   21 declarations: $@1 declaration .

    $default  reduce using rule 21 (declarations)


State 20

  113 functions: functions function .

    $default  reduce using rule 113 (functions)


State 21

  119 function_head: FUNC . IDENT LEFT_PAREN param_empty RIGHT_PAREN type

    IDENT  shift, and go to state 32


State 22

  116 function: $@2 function_head . function_tail
  120 function_tail: . LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET

    LEFT_CURLY_BRACKET  shift, and go to state 33

    function_tail  go to state 34


State 23

  126 enum_statement: ENUM IDENT LEFT_CURLY_BRACKET . enum_list RIGHT_CURLY_BRACKET SEMICOLON
  127 enum_list: . one_val
  128          | . enum_list COMMA one_val
  129 one_val: . IDENT
  130        | . IDENT ASSIGN_OP value

    IDENT  shift, and go to state 35

    enum_list  go to state 36
    one_val    go to state 37


State 24

    9 type: INTEGER .

    $default  reduce using rule 9 (type)


State 25

   10 type: FLOAT .

    $default  reduce using rule 10 (type)


State 26

   11 type: DOUBLE .

    $default  reduce using rule 11 (type)


State 27

   12 type: VOID .

    $default  reduce using rule 12 (type)


State 28

   13 type: BOOLEAN .

    $default  reduce using rule 13 (type)


State 29

   14 type: CHAR .

    $default  reduce using rule 14 (type)


State 30

   15 type: STR .

    $default  reduce using rule 15 (type)


State 31

   18 declaration: beforedecl type . IDENT SEMICOLON
   19            | beforedecl type . IDENT ASSIGN_OP expression SEMICOLON

    IDENT  shift, and go to state 38


State 32

  119 function_head: FUNC IDENT . LEFT_PAREN param_empty RIGHT_PAREN type

    LEFT_PAREN  shift, and go to state 39


State 33

   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   80 if_statement: . IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part
   81 while_statement: . WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop
   84 for_statement: . FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop
   85 do_statement: . DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON
   86 switch_statement: . SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET
   94 return_statement: . RETURN return_val SEMICOLON
   95 break_statement: . BREAK SEMICOLON
   96 continue_statement: . CONTINUE SEMICOLON
   97 expression_statement: . expression SEMICOLON
   98 statements: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, IDENT, CONST_INT, CONST_FLOAT, CONST_CHAR, STRING_LITERAL, IF, WHILE, FOR, DO, SWITCH, RETURN, BREAK, CONTINUE, TRUE_TOKEN, FALSE_TOKEN, ENUM, LEFT_PAREN, RIGHT_CURLY_BRACKET, INC_OP, DEC_OP, NOT_OP]
   99           | . statement
  100           | . statements statement
  101 statement: . if_statement
  102          | . while_statement
  103          | . for_statement
  104          | . do_statement
  105          | . switch_statement
  106          | . return_statement
  107          | . expression_statement
  108          | . declarations
  109          | . enum_statement
  110          | . func_call
  111          | . break_statement
  112          | . continue_statement
  120 function_tail: LEFT_CURLY_BRACKET . statements RIGHT_CURLY_BRACKET
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON
  131 func_call: . IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | . IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    IDENT           shift, and go to state 40
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    IF              shift, and go to state 45
    WHILE           shift, and go to state 46
    FOR             shift, and go to state 47
    DO              shift, and go to state 48
    SWITCH          shift, and go to state 49
    RETURN          shift, and go to state 50
    BREAK           shift, and go to state 51
    CONTINUE        shift, and go to state 52
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    ENUM            shift, and go to state 1
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    INTEGER              reduce using rule 20 ($@1)
    INTEGER              [reduce using rule 98 (statements)]
    FLOAT                reduce using rule 20 ($@1)
    FLOAT                [reduce using rule 98 (statements)]
    DOUBLE               reduce using rule 20 ($@1)
    DOUBLE               [reduce using rule 98 (statements)]
    VOID                 reduce using rule 20 ($@1)
    VOID                 [reduce using rule 98 (statements)]
    BOOLEAN              reduce using rule 20 ($@1)
    BOOLEAN              [reduce using rule 98 (statements)]
    CHAR                 reduce using rule 20 ($@1)
    CHAR                 [reduce using rule 98 (statements)]
    CONST                reduce using rule 20 ($@1)
    CONST                [reduce using rule 98 (statements)]
    STR                  reduce using rule 20 ($@1)
    STR                  [reduce using rule 98 (statements)]
    IDENT                [reduce using rule 98 (statements)]
    CONST_INT            [reduce using rule 98 (statements)]
    CONST_FLOAT          [reduce using rule 98 (statements)]
    CONST_CHAR           [reduce using rule 98 (statements)]
    STRING_LITERAL       [reduce using rule 98 (statements)]
    IF                   [reduce using rule 98 (statements)]
    WHILE                [reduce using rule 98 (statements)]
    FOR                  [reduce using rule 98 (statements)]
    DO                   [reduce using rule 98 (statements)]
    SWITCH               [reduce using rule 98 (statements)]
    RETURN               [reduce using rule 98 (statements)]
    BREAK                [reduce using rule 98 (statements)]
    CONTINUE             [reduce using rule 98 (statements)]
    TRUE_TOKEN           [reduce using rule 98 (statements)]
    FALSE_TOKEN          [reduce using rule 98 (statements)]
    ENUM                 [reduce using rule 98 (statements)]
    LEFT_PAREN           [reduce using rule 98 (statements)]
    RIGHT_CURLY_BRACKET  reduce using rule 98 (statements)
    INC_OP               [reduce using rule 98 (statements)]
    DEC_OP               [reduce using rule 98 (statements)]
    NOT_OP               [reduce using rule 98 (statements)]
    $default             reduce using rule 20 ($@1)

    declarations          go to state 59
    $@1                   go to state 6
    bool_expression       go to state 60
    assign                go to state 61
    expression            go to state 62
    simpleExp             go to state 63
    andExp                go to state 64
    bitRelExp             go to state 65
    relExp                go to state 66
    bitshiftExp           go to state 67
    sumExp                go to state 68
    mulExp                go to state 69
    unaryExp              go to state 70
    value                 go to state 71
    if_statement          go to state 72
    while_statement       go to state 73
    for_statement         go to state 74
    do_statement          go to state 75
    switch_statement      go to state 76
    return_statement      go to state 77
    break_statement       go to state 78
    continue_statement    go to state 79
    expression_statement  go to state 80
    statements            go to state 81
    statement             go to state 82
    enum_statement        go to state 83
    func_call             go to state 84


State 34

  116 function: $@2 function_head function_tail .

    $default  reduce using rule 116 (function)


State 35

  129 one_val: IDENT .  [RIGHT_CURLY_BRACKET, COMMA]
  130        | IDENT . ASSIGN_OP value

    ASSIGN_OP  shift, and go to state 85

    $default  reduce using rule 129 (one_val)


State 36

  126 enum_statement: ENUM IDENT LEFT_CURLY_BRACKET enum_list . RIGHT_CURLY_BRACKET SEMICOLON
  128 enum_list: enum_list . COMMA one_val

    RIGHT_CURLY_BRACKET  shift, and go to state 86
    COMMA                shift, and go to state 87


State 37

  127 enum_list: one_val .

    $default  reduce using rule 127 (enum_list)


State 38

   18 declaration: beforedecl type IDENT . SEMICOLON
   19            | beforedecl type IDENT . ASSIGN_OP expression SEMICOLON

    SEMICOLON  shift, and go to state 88
    ASSIGN_OP  shift, and go to state 89


State 39

  117 param_empty: . parameters
  118            | . %empty  [RIGHT_PAREN]
  119 function_head: FUNC IDENT LEFT_PAREN . param_empty RIGHT_PAREN type
  121 parameters: . parameter
  122           | . parameters COMMA parameter
  123           | . %empty  [RIGHT_PAREN, COMMA]
  124 $@3: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, STR]
  125 parameter: . $@3 type IDENT

    RIGHT_PAREN  reduce using rule 118 (param_empty)
    RIGHT_PAREN  [reduce using rule 123 (parameters)]
    COMMA        reduce using rule 123 (parameters)
    $default     reduce using rule 124 ($@3)

    param_empty  go to state 90
    parameters   go to state 91
    parameter    go to state 92
    $@3          go to state 93


State 40

   28 assign: IDENT . ASSIGN_OP expression
   30 expression: IDENT . INC_OP
   31           | IDENT . DEC_OP
   33           | IDENT .  [SEMICOLON]
   68 unaryExp: IDENT .  [SEMICOLON, ADD_OP, SUB_OP, MUL_OP, DIV_OP, MOD_OP, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP, BIT_LSHIFT_OP, BIT_RSHIFT_OP, EQ_OP, NE_OP, GT_OP, LT_OP, GE_OP, LE_OP]
  131 func_call: IDENT . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | IDENT . ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    LEFT_PAREN  shift, and go to state 94
    INC_OP      shift, and go to state 95
    DEC_OP      shift, and go to state 96
    ASSIGN_OP   shift, and go to state 97

    SEMICOLON  reduce using rule 33 (expression)
    SEMICOLON  [reduce using rule 68 (unaryExp)]
    $default   reduce using rule 68 (unaryExp)


State 41

   71 value: CONST_INT .

    $default  reduce using rule 71 (value)


State 42

   72 value: CONST_FLOAT .

    $default  reduce using rule 72 (value)


State 43

   73 value: CONST_CHAR .

    $default  reduce using rule 73 (value)


State 44

   74 value: STRING_LITERAL .

    $default  reduce using rule 74 (value)


State 45

   80 if_statement: IF . LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part

    LEFT_PAREN  shift, and go to state 98


State 46

   81 while_statement: WHILE . LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop

    LEFT_PAREN  shift, and go to state 99


State 47

   84 for_statement: FOR . LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop

    LEFT_PAREN  shift, and go to state 100


State 48

   24 tail_inloop: . LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET
   85 do_statement: DO . tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON

    LEFT_CURLY_BRACKET  shift, and go to state 101

    tail_inloop  go to state 102


State 49

   86 switch_statement: SWITCH . LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET

    LEFT_PAREN  shift, and go to state 103


State 50

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   92 return_val: . expression
   93           | . %empty  [SEMICOLON]
   94 return_statement: RETURN . return_val SEMICOLON

    IDENT           shift, and go to state 104
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    $default  reduce using rule 93 (return_val)

    bool_expression  go to state 60
    assign           go to state 61
    expression       go to state 105
    simpleExp        go to state 63
    andExp           go to state 64
    bitRelExp        go to state 65
    relExp           go to state 66
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71
    return_val       go to state 106


State 51

   95 break_statement: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 107


State 52

   96 continue_statement: CONTINUE . SEMICOLON

    SEMICOLON  shift, and go to state 108


State 53

   26 bool_expression: TRUE_TOKEN .

    $default  reduce using rule 26 (bool_expression)


State 54

   27 bool_expression: FALSE_TOKEN .

    $default  reduce using rule 27 (bool_expression)


State 55

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   70         | LEFT_PAREN . expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 104
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 60
    assign           go to state 61
    expression       go to state 109
    simpleExp        go to state 63
    andExp           go to state 64
    bitRelExp        go to state 65
    relExp           go to state 66
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 56

   65 unaryExp: INC_OP . IDENT

    IDENT  shift, and go to state 110


State 57

   66 unaryExp: DEC_OP . IDENT

    IDENT  shift, and go to state 111


State 58

   67 unaryExp: NOT_OP . IDENT

    IDENT  shift, and go to state 112


State 59

   16 beforedecl: . CONST
   17           | . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, STR]
   18 declaration: . beforedecl type IDENT SEMICOLON
   19            | . beforedecl type IDENT ASSIGN_OP expression SEMICOLON
   22 declarations: declarations . declaration
  108 statement: declarations .  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, IDENT, CONST_INT, CONST_FLOAT, CONST_CHAR, STRING_LITERAL, IF, WHILE, FOR, DO, SWITCH, CASE, DEFAULT, RETURN, BREAK, CONTINUE, TRUE_TOKEN, FALSE_TOKEN, ENUM, LEFT_PAREN, RIGHT_CURLY_BRACKET, INC_OP, DEC_OP, NOT_OP]

    CONST  shift, and go to state 16

    INTEGER   reduce using rule 17 (beforedecl)
    INTEGER   [reduce using rule 108 (statement)]
    FLOAT     reduce using rule 17 (beforedecl)
    FLOAT     [reduce using rule 108 (statement)]
    DOUBLE    reduce using rule 17 (beforedecl)
    DOUBLE    [reduce using rule 108 (statement)]
    VOID      reduce using rule 17 (beforedecl)
    VOID      [reduce using rule 108 (statement)]
    BOOLEAN   reduce using rule 17 (beforedecl)
    BOOLEAN   [reduce using rule 108 (statement)]
    CHAR      reduce using rule 17 (beforedecl)
    CHAR      [reduce using rule 108 (statement)]
    CONST     [reduce using rule 108 (statement)]
    STR       reduce using rule 17 (beforedecl)
    STR       [reduce using rule 108 (statement)]
    $default  reduce using rule 108 (statement)

    beforedecl   go to state 17
    declaration  go to state 18


State 60

   34 expression: bool_expression .

    $default  reduce using rule 34 (expression)


State 61

   29 expression: assign .

    $default  reduce using rule 29 (expression)


State 62

   97 expression_statement: expression . SEMICOLON

    SEMICOLON  shift, and go to state 113


State 63

   32 expression: simpleExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON]
   35 simpleExp: simpleExp . OR_OP andExp

    OR_OP  shift, and go to state 114

    $default  reduce using rule 32 (expression)


State 64

   36 simpleExp: andExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP]
   37 andExp: andExp . AND_OP

    AND_OP  shift, and go to state 115

    $default  reduce using rule 36 (simpleExp)


State 65

   38 andExp: bitRelExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP, AND_OP]
   39 bitRelExp: bitRelExp . BIT_OR_OP relExp
   40          | bitRelExp . AND relExp
   41          | bitRelExp . BIT_XOR_OP relExp

    BIT_OR_OP   shift, and go to state 116
    AND         shift, and go to state 117
    BIT_XOR_OP  shift, and go to state 118

    $default  reduce using rule 38 (andExp)


State 66

   25 bool_expression: relExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON]
   42 bitRelExp: relExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP]
   43 op: . EQ_OP
   44   | . NE_OP
   45   | . GT_OP
   46   | . LT_OP
   47   | . LE_OP
   48   | . GE_OP
   49   | . OR_OP
   50   | . AND_OP
   51 relExp: relExp . op bitshiftExp

    OR_OP   shift, and go to state 119
    AND_OP  shift, and go to state 120
    EQ_OP   shift, and go to state 121
    NE_OP   shift, and go to state 122
    GT_OP   shift, and go to state 123
    LT_OP   shift, and go to state 124
    GE_OP   shift, and go to state 125
    LE_OP   shift, and go to state 126

    RIGHT_PAREN  reduce using rule 25 (bool_expression)
    RIGHT_PAREN  [reduce using rule 42 (bitRelExp)]
    SEMICOLON    reduce using rule 25 (bool_expression)
    SEMICOLON    [reduce using rule 42 (bitRelExp)]
    COMMA        reduce using rule 25 (bool_expression)
    COMMA        [reduce using rule 42 (bitRelExp)]
    COLON        reduce using rule 25 (bool_expression)
    COLON        [reduce using rule 42 (bitRelExp)]
    OR_OP        [reduce using rule 42 (bitRelExp)]
    AND_OP       [reduce using rule 42 (bitRelExp)]
    BIT_OR_OP    reduce using rule 42 (bitRelExp)
    AND          reduce using rule 42 (bitRelExp)
    BIT_XOR_OP   reduce using rule 42 (bitRelExp)
    $default     reduce using rule 25 (bool_expression)

    op  go to state 127


State 67

   52 relExp: bitshiftExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP, EQ_OP, NE_OP, GT_OP, LT_OP, GE_OP, LE_OP]
   53 bitshiftExp: bitshiftExp . BIT_LSHIFT_OP sumExp
   54            | bitshiftExp . BIT_RSHIFT_OP sumExp

    BIT_LSHIFT_OP  shift, and go to state 128
    BIT_RSHIFT_OP  shift, and go to state 129

    $default  reduce using rule 52 (relExp)


State 68

   55 bitshiftExp: sumExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP, BIT_LSHIFT_OP, BIT_RSHIFT_OP, EQ_OP, NE_OP, GT_OP, LT_OP, GE_OP, LE_OP]
   56 pls_min: . ADD_OP
   57        | . SUB_OP
   61 sumExp: sumExp . pls_min mulExp

    ADD_OP  shift, and go to state 130
    SUB_OP  shift, and go to state 131

    $default  reduce using rule 55 (bitshiftExp)

    pls_min  go to state 132


State 69

   58 mul_div: . MUL_OP
   59        | . DIV_OP
   60        | . MOD_OP
   62 sumExp: mulExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, ADD_OP, SUB_OP, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP, BIT_LSHIFT_OP, BIT_RSHIFT_OP, EQ_OP, NE_OP, GT_OP, LT_OP, GE_OP, LE_OP]
   63 mulExp: mulExp . mul_div unaryExp

    MUL_OP  shift, and go to state 133
    DIV_OP  shift, and go to state 134
    MOD_OP  shift, and go to state 135

    $default  reduce using rule 62 (sumExp)

    mul_div  go to state 136


State 70

   64 mulExp: unaryExp .

    $default  reduce using rule 64 (mulExp)


State 71

   69 unaryExp: value .

    $default  reduce using rule 69 (unaryExp)


State 72

  101 statement: if_statement .

    $default  reduce using rule 101 (statement)


State 73

  102 statement: while_statement .

    $default  reduce using rule 102 (statement)


State 74

  103 statement: for_statement .

    $default  reduce using rule 103 (statement)


State 75

  104 statement: do_statement .

    $default  reduce using rule 104 (statement)


State 76

  105 statement: switch_statement .

    $default  reduce using rule 105 (statement)


State 77

  106 statement: return_statement .

    $default  reduce using rule 106 (statement)


State 78

  111 statement: break_statement .

    $default  reduce using rule 111 (statement)


State 79

  112 statement: continue_statement .

    $default  reduce using rule 112 (statement)


State 80

  107 statement: expression_statement .

    $default  reduce using rule 107 (statement)


State 81

   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   80 if_statement: . IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part
   81 while_statement: . WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop
   84 for_statement: . FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop
   85 do_statement: . DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON
   86 switch_statement: . SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET
   94 return_statement: . RETURN return_val SEMICOLON
   95 break_statement: . BREAK SEMICOLON
   96 continue_statement: . CONTINUE SEMICOLON
   97 expression_statement: . expression SEMICOLON
  100 statements: statements . statement
  101 statement: . if_statement
  102          | . while_statement
  103          | . for_statement
  104          | . do_statement
  105          | . switch_statement
  106          | . return_statement
  107          | . expression_statement
  108          | . declarations
  109          | . enum_statement
  110          | . func_call
  111          | . break_statement
  112          | . continue_statement
  120 function_tail: LEFT_CURLY_BRACKET statements . RIGHT_CURLY_BRACKET
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON
  131 func_call: . IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | . IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    IDENT                shift, and go to state 40
    CONST_INT            shift, and go to state 41
    CONST_FLOAT          shift, and go to state 42
    CONST_CHAR           shift, and go to state 43
    STRING_LITERAL       shift, and go to state 44
    IF                   shift, and go to state 45
    WHILE                shift, and go to state 46
    FOR                  shift, and go to state 47
    DO                   shift, and go to state 48
    SWITCH               shift, and go to state 49
    RETURN               shift, and go to state 50
    BREAK                shift, and go to state 51
    CONTINUE             shift, and go to state 52
    TRUE_TOKEN           shift, and go to state 53
    FALSE_TOKEN          shift, and go to state 54
    ENUM                 shift, and go to state 1
    LEFT_PAREN           shift, and go to state 55
    RIGHT_CURLY_BRACKET  shift, and go to state 137
    INC_OP               shift, and go to state 56
    DEC_OP               shift, and go to state 57
    NOT_OP               shift, and go to state 58

    $default  reduce using rule 20 ($@1)

    declarations          go to state 59
    $@1                   go to state 6
    bool_expression       go to state 60
    assign                go to state 61
    expression            go to state 62
    simpleExp             go to state 63
    andExp                go to state 64
    bitRelExp             go to state 65
    relExp                go to state 66
    bitshiftExp           go to state 67
    sumExp                go to state 68
    mulExp                go to state 69
    unaryExp              go to state 70
    value                 go to state 71
    if_statement          go to state 72
    while_statement       go to state 73
    for_statement         go to state 74
    do_statement          go to state 75
    switch_statement      go to state 76
    return_statement      go to state 77
    break_statement       go to state 78
    continue_statement    go to state 79
    expression_statement  go to state 80
    statement             go to state 138
    enum_statement        go to state 83
    func_call             go to state 84


State 82

   99 statements: statement .

    $default  reduce using rule 99 (statements)


State 83

  109 statement: enum_statement .

    $default  reduce using rule 109 (statement)


State 84

  110 statement: func_call .

    $default  reduce using rule 110 (statement)


State 85

   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
  130 one_val: IDENT ASSIGN_OP . value

    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44

    value  go to state 139


State 86

  126 enum_statement: ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET . SEMICOLON

    SEMICOLON  shift, and go to state 140


State 87

  128 enum_list: enum_list COMMA . one_val
  129 one_val: . IDENT
  130        | . IDENT ASSIGN_OP value

    IDENT  shift, and go to state 35

    one_val  go to state 141


State 88

   18 declaration: beforedecl type IDENT SEMICOLON .

    $default  reduce using rule 18 (declaration)


State 89

   19 declaration: beforedecl type IDENT ASSIGN_OP . expression SEMICOLON
   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 104
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 60
    assign           go to state 61
    expression       go to state 142
    simpleExp        go to state 63
    andExp           go to state 64
    bitRelExp        go to state 65
    relExp           go to state 66
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 90

  119 function_head: FUNC IDENT LEFT_PAREN param_empty . RIGHT_PAREN type

    RIGHT_PAREN  shift, and go to state 143


State 91

  117 param_empty: parameters .  [RIGHT_PAREN]
  122 parameters: parameters . COMMA parameter

    COMMA  shift, and go to state 144

    $default  reduce using rule 117 (param_empty)


State 92

  121 parameters: parameter .

    $default  reduce using rule 121 (parameters)


State 93

    9 type: . INTEGER
   10     | . FLOAT
   11     | . DOUBLE
   12     | . VOID
   13     | . BOOLEAN
   14     | . CHAR
   15     | . STR
  125 parameter: $@3 . type IDENT

    INTEGER  shift, and go to state 24
    FLOAT    shift, and go to state 25
    DOUBLE   shift, and go to state 26
    VOID     shift, and go to state 27
    BOOLEAN  shift, and go to state 28
    CHAR     shift, and go to state 29
    STR      shift, and go to state 30

    type  go to state 145


State 94

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
  131 func_call: IDENT LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
  133 arguments: . argument
  134          | . arguments COMMA argument
  135          | . %empty  [RIGHT_PAREN, COMMA]
  136 argument: . expression

    IDENT           shift, and go to state 104
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    $default  reduce using rule 135 (arguments)

    bool_expression  go to state 60
    assign           go to state 61
    expression       go to state 146
    simpleExp        go to state 63
    andExp           go to state 64
    bitRelExp        go to state 65
    relExp           go to state 66
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71
    arguments        go to state 147
    argument         go to state 148


State 95

   30 expression: IDENT INC_OP .

    $default  reduce using rule 30 (expression)


State 96

   31 expression: IDENT DEC_OP .

    $default  reduce using rule 31 (expression)


State 97

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   28       | IDENT ASSIGN_OP . expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
  132 func_call: IDENT ASSIGN_OP . IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    IDENT           shift, and go to state 149
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 60
    assign           go to state 61
    expression       go to state 150
    simpleExp        go to state 63
    andExp           go to state 64
    bitRelExp        go to state 65
    relExp           go to state 66
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 98

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   80 if_statement: IF LEFT_PAREN . bool_expression RIGHT_PAREN tail else_if else_part

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 152
    relExp           go to state 153
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 99

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   81 while_statement: WHILE LEFT_PAREN . bool_expression RIGHT_PAREN tail_inloop

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 154
    relExp           go to state 153
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 100

    9 type: . INTEGER
   10     | . FLOAT
   11     | . DOUBLE
   12     | . VOID
   13     | . BOOLEAN
   14     | . CHAR
   15     | . STR
   82 optional_type: . %empty  [IDENT]
   83              | . type
   84 for_statement: FOR LEFT_PAREN . optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop

    INTEGER  shift, and go to state 24
    FLOAT    shift, and go to state 25
    DOUBLE   shift, and go to state 26
    VOID     shift, and go to state 27
    BOOLEAN  shift, and go to state 28
    CHAR     shift, and go to state 29
    STR      shift, and go to state 30

    $default  reduce using rule 82 (optional_type)

    type           go to state 155
    optional_type  go to state 156


State 101

   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
   24 tail_inloop: LEFT_CURLY_BRACKET . statements RIGHT_CURLY_BRACKET
   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   80 if_statement: . IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part
   81 while_statement: . WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop
   84 for_statement: . FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop
   85 do_statement: . DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON
   86 switch_statement: . SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET
   94 return_statement: . RETURN return_val SEMICOLON
   95 break_statement: . BREAK SEMICOLON
   96 continue_statement: . CONTINUE SEMICOLON
   97 expression_statement: . expression SEMICOLON
   98 statements: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, IDENT, CONST_INT, CONST_FLOAT, CONST_CHAR, STRING_LITERAL, IF, WHILE, FOR, DO, SWITCH, RETURN, BREAK, CONTINUE, TRUE_TOKEN, FALSE_TOKEN, ENUM, LEFT_PAREN, RIGHT_CURLY_BRACKET, INC_OP, DEC_OP, NOT_OP]
   99           | . statement
  100           | . statements statement
  101 statement: . if_statement
  102          | . while_statement
  103          | . for_statement
  104          | . do_statement
  105          | . switch_statement
  106          | . return_statement
  107          | . expression_statement
  108          | . declarations
  109          | . enum_statement
  110          | . func_call
  111          | . break_statement
  112          | . continue_statement
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON
  131 func_call: . IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | . IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    IDENT           shift, and go to state 40
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    IF              shift, and go to state 45
    WHILE           shift, and go to state 46
    FOR             shift, and go to state 47
    DO              shift, and go to state 48
    SWITCH          shift, and go to state 49
    RETURN          shift, and go to state 50
    BREAK           shift, and go to state 51
    CONTINUE        shift, and go to state 52
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    ENUM            shift, and go to state 1
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    INTEGER              reduce using rule 20 ($@1)
    INTEGER              [reduce using rule 98 (statements)]
    FLOAT                reduce using rule 20 ($@1)
    FLOAT                [reduce using rule 98 (statements)]
    DOUBLE               reduce using rule 20 ($@1)
    DOUBLE               [reduce using rule 98 (statements)]
    VOID                 reduce using rule 20 ($@1)
    VOID                 [reduce using rule 98 (statements)]
    BOOLEAN              reduce using rule 20 ($@1)
    BOOLEAN              [reduce using rule 98 (statements)]
    CHAR                 reduce using rule 20 ($@1)
    CHAR                 [reduce using rule 98 (statements)]
    CONST                reduce using rule 20 ($@1)
    CONST                [reduce using rule 98 (statements)]
    STR                  reduce using rule 20 ($@1)
    STR                  [reduce using rule 98 (statements)]
    IDENT                [reduce using rule 98 (statements)]
    CONST_INT            [reduce using rule 98 (statements)]
    CONST_FLOAT          [reduce using rule 98 (statements)]
    CONST_CHAR           [reduce using rule 98 (statements)]
    STRING_LITERAL       [reduce using rule 98 (statements)]
    IF                   [reduce using rule 98 (statements)]
    WHILE                [reduce using rule 98 (statements)]
    FOR                  [reduce using rule 98 (statements)]
    DO                   [reduce using rule 98 (statements)]
    SWITCH               [reduce using rule 98 (statements)]
    RETURN               [reduce using rule 98 (statements)]
    BREAK                [reduce using rule 98 (statements)]
    CONTINUE             [reduce using rule 98 (statements)]
    TRUE_TOKEN           [reduce using rule 98 (statements)]
    FALSE_TOKEN          [reduce using rule 98 (statements)]
    ENUM                 [reduce using rule 98 (statements)]
    LEFT_PAREN           [reduce using rule 98 (statements)]
    RIGHT_CURLY_BRACKET  reduce using rule 98 (statements)
    INC_OP               [reduce using rule 98 (statements)]
    DEC_OP               [reduce using rule 98 (statements)]
    NOT_OP               [reduce using rule 98 (statements)]
    $default             reduce using rule 20 ($@1)

    declarations          go to state 59
    $@1                   go to state 6
    bool_expression       go to state 60
    assign                go to state 61
    expression            go to state 62
    simpleExp             go to state 63
    andExp                go to state 64
    bitRelExp             go to state 65
    relExp                go to state 66
    bitshiftExp           go to state 67
    sumExp                go to state 68
    mulExp                go to state 69
    unaryExp              go to state 70
    value                 go to state 71
    if_statement          go to state 72
    while_statement       go to state 73
    for_statement         go to state 74
    do_statement          go to state 75
    switch_statement      go to state 76
    return_statement      go to state 77
    break_statement       go to state 78
    continue_statement    go to state 79
    expression_statement  go to state 80
    statements            go to state 157
    statement             go to state 82
    enum_statement        go to state 83
    func_call             go to state 84


State 102

   85 do_statement: DO tail_inloop . UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON

    UNTIL  shift, and go to state 158


State 103

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   86 switch_statement: SWITCH LEFT_PAREN . expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET

    IDENT           shift, and go to state 104
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 60
    assign           go to state 61
    expression       go to state 159
    simpleExp        go to state 63
    andExp           go to state 64
    bitRelExp        go to state 65
    relExp           go to state 66
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 104

   28 assign: IDENT . ASSIGN_OP expression
   30 expression: IDENT . INC_OP
   31           | IDENT . DEC_OP
   33           | IDENT .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON]
   68 unaryExp: IDENT .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, ADD_OP, SUB_OP, MUL_OP, DIV_OP, MOD_OP, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP, BIT_LSHIFT_OP, BIT_RSHIFT_OP, EQ_OP, NE_OP, GT_OP, LT_OP, GE_OP, LE_OP]

    INC_OP     shift, and go to state 95
    DEC_OP     shift, and go to state 96
    ASSIGN_OP  shift, and go to state 160

    RIGHT_PAREN  reduce using rule 33 (expression)
    RIGHT_PAREN  [reduce using rule 68 (unaryExp)]
    SEMICOLON    reduce using rule 33 (expression)
    SEMICOLON    [reduce using rule 68 (unaryExp)]
    COMMA        reduce using rule 33 (expression)
    COMMA        [reduce using rule 68 (unaryExp)]
    COLON        reduce using rule 33 (expression)
    COLON        [reduce using rule 68 (unaryExp)]
    $default     reduce using rule 68 (unaryExp)


State 105

   92 return_val: expression .

    $default  reduce using rule 92 (return_val)


State 106

   94 return_statement: RETURN return_val . SEMICOLON

    SEMICOLON  shift, and go to state 161


State 107

   95 break_statement: BREAK SEMICOLON .

    $default  reduce using rule 95 (break_statement)


State 108

   96 continue_statement: CONTINUE SEMICOLON .

    $default  reduce using rule 96 (continue_statement)


State 109

   70 unaryExp: LEFT_PAREN expression . RIGHT_PAREN

    RIGHT_PAREN  shift, and go to state 162


State 110

   65 unaryExp: INC_OP IDENT .

    $default  reduce using rule 65 (unaryExp)


State 111

   66 unaryExp: DEC_OP IDENT .

    $default  reduce using rule 66 (unaryExp)


State 112

   67 unaryExp: NOT_OP IDENT .

    $default  reduce using rule 67 (unaryExp)


State 113

   97 expression_statement: expression SEMICOLON .

    $default  reduce using rule 97 (expression_statement)


State 114

   35 simpleExp: simpleExp OR_OP . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    andExp       go to state 163
    bitRelExp    go to state 65
    relExp       go to state 164
    bitshiftExp  go to state 67
    sumExp       go to state 68
    mulExp       go to state 69
    unaryExp     go to state 70
    value        go to state 71


State 115

   37 andExp: andExp AND_OP .

    $default  reduce using rule 37 (andExp)


State 116

   39 bitRelExp: bitRelExp BIT_OR_OP . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    relExp       go to state 165
    bitshiftExp  go to state 67
    sumExp       go to state 68
    mulExp       go to state 69
    unaryExp     go to state 70
    value        go to state 71


State 117

   40 bitRelExp: bitRelExp AND . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    relExp       go to state 166
    bitshiftExp  go to state 67
    sumExp       go to state 68
    mulExp       go to state 69
    unaryExp     go to state 70
    value        go to state 71


State 118

   41 bitRelExp: bitRelExp BIT_XOR_OP . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    relExp       go to state 167
    bitshiftExp  go to state 67
    sumExp       go to state 68
    mulExp       go to state 69
    unaryExp     go to state 70
    value        go to state 71


State 119

   49 op: OR_OP .

    $default  reduce using rule 49 (op)


State 120

   50 op: AND_OP .

    $default  reduce using rule 50 (op)


State 121

   43 op: EQ_OP .

    $default  reduce using rule 43 (op)


State 122

   44 op: NE_OP .

    $default  reduce using rule 44 (op)


State 123

   45 op: GT_OP .

    $default  reduce using rule 45 (op)


State 124

   46 op: LT_OP .

    $default  reduce using rule 46 (op)


State 125

   48 op: GE_OP .

    $default  reduce using rule 48 (op)


State 126

   47 op: LE_OP .

    $default  reduce using rule 47 (op)


State 127

   51 relExp: relExp op . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bitshiftExp  go to state 168
    sumExp       go to state 68
    mulExp       go to state 69
    unaryExp     go to state 70
    value        go to state 71


State 128

   53 bitshiftExp: bitshiftExp BIT_LSHIFT_OP . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    sumExp    go to state 169
    mulExp    go to state 69
    unaryExp  go to state 70
    value     go to state 71


State 129

   54 bitshiftExp: bitshiftExp BIT_RSHIFT_OP . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    sumExp    go to state 170
    mulExp    go to state 69
    unaryExp  go to state 70
    value     go to state 71


State 130

   56 pls_min: ADD_OP .

    $default  reduce using rule 56 (pls_min)


State 131

   57 pls_min: SUB_OP .

    $default  reduce using rule 57 (pls_min)


State 132

   61 sumExp: sumExp pls_min . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    mulExp    go to state 171
    unaryExp  go to state 70
    value     go to state 71


State 133

   58 mul_div: MUL_OP .

    $default  reduce using rule 58 (mul_div)


State 134

   59 mul_div: DIV_OP .

    $default  reduce using rule 59 (mul_div)


State 135

   60 mul_div: MOD_OP .

    $default  reduce using rule 60 (mul_div)


State 136

   63 mulExp: mulExp mul_div . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    unaryExp  go to state 172
    value     go to state 71


State 137

  120 function_tail: LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET .

    $default  reduce using rule 120 (function_tail)


State 138

  100 statements: statements statement .

    $default  reduce using rule 100 (statements)


State 139

  130 one_val: IDENT ASSIGN_OP value .

    $default  reduce using rule 130 (one_val)


State 140

  126 enum_statement: ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON .

    $default  reduce using rule 126 (enum_statement)


State 141

  128 enum_list: enum_list COMMA one_val .

    $default  reduce using rule 128 (enum_list)


State 142

   19 declaration: beforedecl type IDENT ASSIGN_OP expression . SEMICOLON

    SEMICOLON  shift, and go to state 173


State 143

    9 type: . INTEGER
   10     | . FLOAT
   11     | . DOUBLE
   12     | . VOID
   13     | . BOOLEAN
   14     | . CHAR
   15     | . STR
  119 function_head: FUNC IDENT LEFT_PAREN param_empty RIGHT_PAREN . type

    INTEGER  shift, and go to state 24
    FLOAT    shift, and go to state 25
    DOUBLE   shift, and go to state 26
    VOID     shift, and go to state 27
    BOOLEAN  shift, and go to state 28
    CHAR     shift, and go to state 29
    STR      shift, and go to state 30

    type  go to state 174


State 144

  122 parameters: parameters COMMA . parameter
  124 $@3: . %empty
  125 parameter: . $@3 type IDENT

    $default  reduce using rule 124 ($@3)

    parameter  go to state 175
    $@3        go to state 93


State 145

  125 parameter: $@3 type . IDENT

    IDENT  shift, and go to state 176


State 146

  136 argument: expression .

    $default  reduce using rule 136 (argument)


State 147

  131 func_call: IDENT LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON
  134 arguments: arguments . COMMA argument

    RIGHT_PAREN  shift, and go to state 177
    COMMA        shift, and go to state 178


State 148

  133 arguments: argument .

    $default  reduce using rule 133 (arguments)


State 149

   28 assign: IDENT . ASSIGN_OP expression
   30 expression: IDENT . INC_OP
   31           | IDENT . DEC_OP
   33           | IDENT .  [SEMICOLON]
   68 unaryExp: IDENT .  [SEMICOLON, ADD_OP, SUB_OP, MUL_OP, DIV_OP, MOD_OP, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP, BIT_LSHIFT_OP, BIT_RSHIFT_OP, EQ_OP, NE_OP, GT_OP, LT_OP, GE_OP, LE_OP]
  132 func_call: IDENT ASSIGN_OP IDENT . LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    LEFT_PAREN  shift, and go to state 179
    INC_OP      shift, and go to state 95
    DEC_OP      shift, and go to state 96
    ASSIGN_OP   shift, and go to state 160

    SEMICOLON  reduce using rule 33 (expression)
    SEMICOLON  [reduce using rule 68 (unaryExp)]
    $default   reduce using rule 68 (unaryExp)


State 150

   28 assign: IDENT ASSIGN_OP expression .

    $default  reduce using rule 28 (assign)


State 151

   68 unaryExp: IDENT .

    $default  reduce using rule 68 (unaryExp)


State 152

   80 if_statement: IF LEFT_PAREN bool_expression . RIGHT_PAREN tail else_if else_part

    RIGHT_PAREN  shift, and go to state 180


State 153

   25 bool_expression: relExp .  [RIGHT_PAREN, SEMICOLON]
   43 op: . EQ_OP
   44   | . NE_OP
   45   | . GT_OP
   46   | . LT_OP
   47   | . LE_OP
   48   | . GE_OP
   49   | . OR_OP
   50   | . AND_OP
   51 relExp: relExp . op bitshiftExp

    OR_OP   shift, and go to state 119
    AND_OP  shift, and go to state 120
    EQ_OP   shift, and go to state 121
    NE_OP   shift, and go to state 122
    GT_OP   shift, and go to state 123
    LT_OP   shift, and go to state 124
    GE_OP   shift, and go to state 125
    LE_OP   shift, and go to state 126

    $default  reduce using rule 25 (bool_expression)

    op  go to state 127


State 154

   81 while_statement: WHILE LEFT_PAREN bool_expression . RIGHT_PAREN tail_inloop

    RIGHT_PAREN  shift, and go to state 181


State 155

   83 optional_type: type .

    $default  reduce using rule 83 (optional_type)


State 156

   28 assign: . IDENT ASSIGN_OP expression
   84 for_statement: FOR LEFT_PAREN optional_type . assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop

    IDENT  shift, and go to state 182

    assign  go to state 183


State 157

   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
   24 tail_inloop: LEFT_CURLY_BRACKET statements . RIGHT_CURLY_BRACKET
   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   80 if_statement: . IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part
   81 while_statement: . WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop
   84 for_statement: . FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop
   85 do_statement: . DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON
   86 switch_statement: . SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET
   94 return_statement: . RETURN return_val SEMICOLON
   95 break_statement: . BREAK SEMICOLON
   96 continue_statement: . CONTINUE SEMICOLON
   97 expression_statement: . expression SEMICOLON
  100 statements: statements . statement
  101 statement: . if_statement
  102          | . while_statement
  103          | . for_statement
  104          | . do_statement
  105          | . switch_statement
  106          | . return_statement
  107          | . expression_statement
  108          | . declarations
  109          | . enum_statement
  110          | . func_call
  111          | . break_statement
  112          | . continue_statement
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON
  131 func_call: . IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | . IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    IDENT                shift, and go to state 40
    CONST_INT            shift, and go to state 41
    CONST_FLOAT          shift, and go to state 42
    CONST_CHAR           shift, and go to state 43
    STRING_LITERAL       shift, and go to state 44
    IF                   shift, and go to state 45
    WHILE                shift, and go to state 46
    FOR                  shift, and go to state 47
    DO                   shift, and go to state 48
    SWITCH               shift, and go to state 49
    RETURN               shift, and go to state 50
    BREAK                shift, and go to state 51
    CONTINUE             shift, and go to state 52
    TRUE_TOKEN           shift, and go to state 53
    FALSE_TOKEN          shift, and go to state 54
    ENUM                 shift, and go to state 1
    LEFT_PAREN           shift, and go to state 55
    RIGHT_CURLY_BRACKET  shift, and go to state 184
    INC_OP               shift, and go to state 56
    DEC_OP               shift, and go to state 57
    NOT_OP               shift, and go to state 58

    $default  reduce using rule 20 ($@1)

    declarations          go to state 59
    $@1                   go to state 6
    bool_expression       go to state 60
    assign                go to state 61
    expression            go to state 62
    simpleExp             go to state 63
    andExp                go to state 64
    bitRelExp             go to state 65
    relExp                go to state 66
    bitshiftExp           go to state 67
    sumExp                go to state 68
    mulExp                go to state 69
    unaryExp              go to state 70
    value                 go to state 71
    if_statement          go to state 72
    while_statement       go to state 73
    for_statement         go to state 74
    do_statement          go to state 75
    switch_statement      go to state 76
    return_statement      go to state 77
    break_statement       go to state 78
    continue_statement    go to state 79
    expression_statement  go to state 80
    statement             go to state 138
    enum_statement        go to state 83
    func_call             go to state 84


State 158

   85 do_statement: DO tail_inloop UNTIL . LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON

    LEFT_PAREN  shift, and go to state 185


State 159

   86 switch_statement: SWITCH LEFT_PAREN expression . RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET

    RIGHT_PAREN  shift, and go to state 186


State 160

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   28       | IDENT ASSIGN_OP . expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL

    IDENT           shift, and go to state 104
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 60
    assign           go to state 61
    expression       go to state 150
    simpleExp        go to state 63
    andExp           go to state 64
    bitRelExp        go to state 65
    relExp           go to state 66
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 161

   94 return_statement: RETURN return_val SEMICOLON .

    $default  reduce using rule 94 (return_statement)


State 162

   70 unaryExp: LEFT_PAREN expression RIGHT_PAREN .

    $default  reduce using rule 70 (unaryExp)


State 163

   35 simpleExp: simpleExp OR_OP andExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP]
   37 andExp: andExp . AND_OP

    AND_OP  shift, and go to state 115

    $default  reduce using rule 35 (simpleExp)


State 164

   42 bitRelExp: relExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP]
   43 op: . EQ_OP
   44   | . NE_OP
   45   | . GT_OP
   46   | . LT_OP
   47   | . LE_OP
   48   | . GE_OP
   49   | . OR_OP
   50   | . AND_OP
   51 relExp: relExp . op bitshiftExp

    OR_OP   shift, and go to state 119
    AND_OP  shift, and go to state 120
    EQ_OP   shift, and go to state 121
    NE_OP   shift, and go to state 122
    GT_OP   shift, and go to state 123
    LT_OP   shift, and go to state 124
    GE_OP   shift, and go to state 125
    LE_OP   shift, and go to state 126

    OR_OP     [reduce using rule 42 (bitRelExp)]
    AND_OP    [reduce using rule 42 (bitRelExp)]
    $default  reduce using rule 42 (bitRelExp)

    op  go to state 127


State 165

   39 bitRelExp: bitRelExp BIT_OR_OP relExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP]
   43 op: . EQ_OP
   44   | . NE_OP
   45   | . GT_OP
   46   | . LT_OP
   47   | . LE_OP
   48   | . GE_OP
   49   | . OR_OP
   50   | . AND_OP
   51 relExp: relExp . op bitshiftExp

    OR_OP   shift, and go to state 119
    AND_OP  shift, and go to state 120
    EQ_OP   shift, and go to state 121
    NE_OP   shift, and go to state 122
    GT_OP   shift, and go to state 123
    LT_OP   shift, and go to state 124
    GE_OP   shift, and go to state 125
    LE_OP   shift, and go to state 126

    OR_OP     [reduce using rule 39 (bitRelExp)]
    AND_OP    [reduce using rule 39 (bitRelExp)]
    $default  reduce using rule 39 (bitRelExp)

    op  go to state 127


State 166

   40 bitRelExp: bitRelExp AND relExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP]
   43 op: . EQ_OP
   44   | . NE_OP
   45   | . GT_OP
   46   | . LT_OP
   47   | . LE_OP
   48   | . GE_OP
   49   | . OR_OP
   50   | . AND_OP
   51 relExp: relExp . op bitshiftExp

    OR_OP   shift, and go to state 119
    AND_OP  shift, and go to state 120
    EQ_OP   shift, and go to state 121
    NE_OP   shift, and go to state 122
    GT_OP   shift, and go to state 123
    LT_OP   shift, and go to state 124
    GE_OP   shift, and go to state 125
    LE_OP   shift, and go to state 126

    OR_OP     [reduce using rule 40 (bitRelExp)]
    AND_OP    [reduce using rule 40 (bitRelExp)]
    $default  reduce using rule 40 (bitRelExp)

    op  go to state 127


State 167

   41 bitRelExp: bitRelExp BIT_XOR_OP relExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP]
   43 op: . EQ_OP
   44   | . NE_OP
   45   | . GT_OP
   46   | . LT_OP
   47   | . LE_OP
   48   | . GE_OP
   49   | . OR_OP
   50   | . AND_OP
   51 relExp: relExp . op bitshiftExp

    OR_OP   shift, and go to state 119
    AND_OP  shift, and go to state 120
    EQ_OP   shift, and go to state 121
    NE_OP   shift, and go to state 122
    GT_OP   shift, and go to state 123
    LT_OP   shift, and go to state 124
    GE_OP   shift, and go to state 125
    LE_OP   shift, and go to state 126

    OR_OP     [reduce using rule 41 (bitRelExp)]
    AND_OP    [reduce using rule 41 (bitRelExp)]
    $default  reduce using rule 41 (bitRelExp)

    op  go to state 127


State 168

   51 relExp: relExp op bitshiftExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP, EQ_OP, NE_OP, GT_OP, LT_OP, GE_OP, LE_OP]
   53 bitshiftExp: bitshiftExp . BIT_LSHIFT_OP sumExp
   54            | bitshiftExp . BIT_RSHIFT_OP sumExp

    BIT_LSHIFT_OP  shift, and go to state 128
    BIT_RSHIFT_OP  shift, and go to state 129

    $default  reduce using rule 51 (relExp)


State 169

   53 bitshiftExp: bitshiftExp BIT_LSHIFT_OP sumExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP, BIT_LSHIFT_OP, BIT_RSHIFT_OP, EQ_OP, NE_OP, GT_OP, LT_OP, GE_OP, LE_OP]
   56 pls_min: . ADD_OP
   57        | . SUB_OP
   61 sumExp: sumExp . pls_min mulExp

    ADD_OP  shift, and go to state 130
    SUB_OP  shift, and go to state 131

    $default  reduce using rule 53 (bitshiftExp)

    pls_min  go to state 132


State 170

   54 bitshiftExp: bitshiftExp BIT_RSHIFT_OP sumExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP, BIT_LSHIFT_OP, BIT_RSHIFT_OP, EQ_OP, NE_OP, GT_OP, LT_OP, GE_OP, LE_OP]
   56 pls_min: . ADD_OP
   57        | . SUB_OP
   61 sumExp: sumExp . pls_min mulExp

    ADD_OP  shift, and go to state 130
    SUB_OP  shift, and go to state 131

    $default  reduce using rule 54 (bitshiftExp)

    pls_min  go to state 132


State 171

   58 mul_div: . MUL_OP
   59        | . DIV_OP
   60        | . MOD_OP
   61 sumExp: sumExp pls_min mulExp .  [RIGHT_PAREN, SEMICOLON, COMMA, COLON, ADD_OP, SUB_OP, OR_OP, AND_OP, BIT_OR_OP, AND, BIT_XOR_OP, BIT_LSHIFT_OP, BIT_RSHIFT_OP, EQ_OP, NE_OP, GT_OP, LT_OP, GE_OP, LE_OP]
   63 mulExp: mulExp . mul_div unaryExp

    MUL_OP  shift, and go to state 133
    DIV_OP  shift, and go to state 134
    MOD_OP  shift, and go to state 135

    $default  reduce using rule 61 (sumExp)

    mul_div  go to state 136


State 172

   63 mulExp: mulExp mul_div unaryExp .

    $default  reduce using rule 63 (mulExp)


State 173

   19 declaration: beforedecl type IDENT ASSIGN_OP expression SEMICOLON .

    $default  reduce using rule 19 (declaration)


State 174

  119 function_head: FUNC IDENT LEFT_PAREN param_empty RIGHT_PAREN type .

    $default  reduce using rule 119 (function_head)


State 175

  122 parameters: parameters COMMA parameter .

    $default  reduce using rule 122 (parameters)


State 176

  125 parameter: $@3 type IDENT .

    $default  reduce using rule 125 (parameter)


State 177

  131 func_call: IDENT LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 187


State 178

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
  134 arguments: arguments COMMA . argument
  136 argument: . expression

    IDENT           shift, and go to state 104
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 60
    assign           go to state 61
    expression       go to state 146
    simpleExp        go to state 63
    andExp           go to state 64
    bitRelExp        go to state 65
    relExp           go to state 66
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71
    argument         go to state 188


State 179

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
  132 func_call: IDENT ASSIGN_OP IDENT LEFT_PAREN . arguments RIGHT_PAREN SEMICOLON
  133 arguments: . argument
  134          | . arguments COMMA argument
  135          | . %empty  [RIGHT_PAREN, COMMA]
  136 argument: . expression

    IDENT           shift, and go to state 104
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    $default  reduce using rule 135 (arguments)

    bool_expression  go to state 60
    assign           go to state 61
    expression       go to state 146
    simpleExp        go to state 63
    andExp           go to state 64
    bitRelExp        go to state 65
    relExp           go to state 66
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71
    arguments        go to state 189
    argument         go to state 148


State 180

   23 tail: . LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET
   80 if_statement: IF LEFT_PAREN bool_expression RIGHT_PAREN . tail else_if else_part

    LEFT_CURLY_BRACKET  shift, and go to state 190

    tail  go to state 191


State 181

   24 tail_inloop: . LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET
   81 while_statement: WHILE LEFT_PAREN bool_expression RIGHT_PAREN . tail_inloop

    LEFT_CURLY_BRACKET  shift, and go to state 101

    tail_inloop  go to state 192


State 182

   28 assign: IDENT . ASSIGN_OP expression

    ASSIGN_OP  shift, and go to state 160


State 183

   84 for_statement: FOR LEFT_PAREN optional_type assign . SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop

    SEMICOLON  shift, and go to state 193


State 184

   24 tail_inloop: LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET .

    $default  reduce using rule 24 (tail_inloop)


State 185

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   85 do_statement: DO tail_inloop UNTIL LEFT_PAREN . bool_expression RIGHT_PAREN SEMICOLON

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 194
    relExp           go to state 153
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 186

   86 switch_statement: SWITCH LEFT_PAREN expression RIGHT_PAREN . LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET

    LEFT_CURLY_BRACKET  shift, and go to state 195


State 187

  131 func_call: IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    $default  reduce using rule 131 (func_call)


State 188

  134 arguments: arguments COMMA argument .

    $default  reduce using rule 134 (arguments)


State 189

  132 func_call: IDENT ASSIGN_OP IDENT LEFT_PAREN arguments . RIGHT_PAREN SEMICOLON
  134 arguments: arguments . COMMA argument

    RIGHT_PAREN  shift, and go to state 196
    COMMA        shift, and go to state 178


State 190

   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
   23 tail: LEFT_CURLY_BRACKET . statements RIGHT_CURLY_BRACKET
   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   80 if_statement: . IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part
   81 while_statement: . WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop
   84 for_statement: . FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop
   85 do_statement: . DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON
   86 switch_statement: . SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET
   94 return_statement: . RETURN return_val SEMICOLON
   95 break_statement: . BREAK SEMICOLON
   96 continue_statement: . CONTINUE SEMICOLON
   97 expression_statement: . expression SEMICOLON
   98 statements: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, IDENT, CONST_INT, CONST_FLOAT, CONST_CHAR, STRING_LITERAL, IF, WHILE, FOR, DO, SWITCH, RETURN, BREAK, CONTINUE, TRUE_TOKEN, FALSE_TOKEN, ENUM, LEFT_PAREN, RIGHT_CURLY_BRACKET, INC_OP, DEC_OP, NOT_OP]
   99           | . statement
  100           | . statements statement
  101 statement: . if_statement
  102          | . while_statement
  103          | . for_statement
  104          | . do_statement
  105          | . switch_statement
  106          | . return_statement
  107          | . expression_statement
  108          | . declarations
  109          | . enum_statement
  110          | . func_call
  111          | . break_statement
  112          | . continue_statement
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON
  131 func_call: . IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | . IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    IDENT           shift, and go to state 40
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    IF              shift, and go to state 45
    WHILE           shift, and go to state 46
    FOR             shift, and go to state 47
    DO              shift, and go to state 48
    SWITCH          shift, and go to state 49
    RETURN          shift, and go to state 50
    BREAK           shift, and go to state 51
    CONTINUE        shift, and go to state 52
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    ENUM            shift, and go to state 1
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    INTEGER              reduce using rule 20 ($@1)
    INTEGER              [reduce using rule 98 (statements)]
    FLOAT                reduce using rule 20 ($@1)
    FLOAT                [reduce using rule 98 (statements)]
    DOUBLE               reduce using rule 20 ($@1)
    DOUBLE               [reduce using rule 98 (statements)]
    VOID                 reduce using rule 20 ($@1)
    VOID                 [reduce using rule 98 (statements)]
    BOOLEAN              reduce using rule 20 ($@1)
    BOOLEAN              [reduce using rule 98 (statements)]
    CHAR                 reduce using rule 20 ($@1)
    CHAR                 [reduce using rule 98 (statements)]
    CONST                reduce using rule 20 ($@1)
    CONST                [reduce using rule 98 (statements)]
    STR                  reduce using rule 20 ($@1)
    STR                  [reduce using rule 98 (statements)]
    IDENT                [reduce using rule 98 (statements)]
    CONST_INT            [reduce using rule 98 (statements)]
    CONST_FLOAT          [reduce using rule 98 (statements)]
    CONST_CHAR           [reduce using rule 98 (statements)]
    STRING_LITERAL       [reduce using rule 98 (statements)]
    IF                   [reduce using rule 98 (statements)]
    WHILE                [reduce using rule 98 (statements)]
    FOR                  [reduce using rule 98 (statements)]
    DO                   [reduce using rule 98 (statements)]
    SWITCH               [reduce using rule 98 (statements)]
    RETURN               [reduce using rule 98 (statements)]
    BREAK                [reduce using rule 98 (statements)]
    CONTINUE             [reduce using rule 98 (statements)]
    TRUE_TOKEN           [reduce using rule 98 (statements)]
    FALSE_TOKEN          [reduce using rule 98 (statements)]
    ENUM                 [reduce using rule 98 (statements)]
    LEFT_PAREN           [reduce using rule 98 (statements)]
    RIGHT_CURLY_BRACKET  reduce using rule 98 (statements)
    INC_OP               [reduce using rule 98 (statements)]
    DEC_OP               [reduce using rule 98 (statements)]
    NOT_OP               [reduce using rule 98 (statements)]
    $default             reduce using rule 20 ($@1)

    declarations          go to state 59
    $@1                   go to state 6
    bool_expression       go to state 60
    assign                go to state 61
    expression            go to state 62
    simpleExp             go to state 63
    andExp                go to state 64
    bitRelExp             go to state 65
    relExp                go to state 66
    bitshiftExp           go to state 67
    sumExp                go to state 68
    mulExp                go to state 69
    unaryExp              go to state 70
    value                 go to state 71
    if_statement          go to state 72
    while_statement       go to state 73
    for_statement         go to state 74
    do_statement          go to state 75
    switch_statement      go to state 76
    return_statement      go to state 77
    break_statement       go to state 78
    continue_statement    go to state 79
    expression_statement  go to state 80
    statements            go to state 197
    statement             go to state 82
    enum_statement        go to state 83
    func_call             go to state 84


State 191

   75 else_if: . ELIF LEFT_PAREN bool_expression RIGHT_PAREN tail
   76        | . else_if ELIF LEFT_PAREN bool_expression RIGHT_PAREN tail
   77        | . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, IDENT, CONST_INT, CONST_FLOAT, CONST_CHAR, STRING_LITERAL, IF, ELSE, ELIF, WHILE, FOR, DO, SWITCH, CASE, DEFAULT, RETURN, BREAK, CONTINUE, TRUE_TOKEN, FALSE_TOKEN, ENUM, LEFT_PAREN, RIGHT_CURLY_BRACKET, INC_OP, DEC_OP, NOT_OP]
   80 if_statement: IF LEFT_PAREN bool_expression RIGHT_PAREN tail . else_if else_part

    ELIF  shift, and go to state 198

    ELIF      [reduce using rule 77 (else_if)]
    $default  reduce using rule 77 (else_if)

    else_if  go to state 199


State 192

   81 while_statement: WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop .

    $default  reduce using rule 81 (while_statement)


State 193

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   84 for_statement: FOR LEFT_PAREN optional_type assign SEMICOLON . bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 200
    relExp           go to state 153
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 194

   85 do_statement: DO tail_inloop UNTIL LEFT_PAREN bool_expression . RIGHT_PAREN SEMICOLON

    RIGHT_PAREN  shift, and go to state 201


State 195

   86 switch_statement: SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET . cases RIGHT_CURLY_BRACKET
   87 cases: . case
   88      | . cases case
   89      | . cases default
   91 case: . CASE expression COLON statements BREAK SEMICOLON

    CASE  shift, and go to state 202

    cases  go to state 203
    case   go to state 204


State 196

  132 func_call: IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 205


State 197

   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
   23 tail: LEFT_CURLY_BRACKET statements . RIGHT_CURLY_BRACKET
   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   80 if_statement: . IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part
   81 while_statement: . WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop
   84 for_statement: . FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop
   85 do_statement: . DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON
   86 switch_statement: . SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET
   94 return_statement: . RETURN return_val SEMICOLON
   95 break_statement: . BREAK SEMICOLON
   96 continue_statement: . CONTINUE SEMICOLON
   97 expression_statement: . expression SEMICOLON
  100 statements: statements . statement
  101 statement: . if_statement
  102          | . while_statement
  103          | . for_statement
  104          | . do_statement
  105          | . switch_statement
  106          | . return_statement
  107          | . expression_statement
  108          | . declarations
  109          | . enum_statement
  110          | . func_call
  111          | . break_statement
  112          | . continue_statement
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON
  131 func_call: . IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | . IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    IDENT                shift, and go to state 40
    CONST_INT            shift, and go to state 41
    CONST_FLOAT          shift, and go to state 42
    CONST_CHAR           shift, and go to state 43
    STRING_LITERAL       shift, and go to state 44
    IF                   shift, and go to state 45
    WHILE                shift, and go to state 46
    FOR                  shift, and go to state 47
    DO                   shift, and go to state 48
    SWITCH               shift, and go to state 49
    RETURN               shift, and go to state 50
    BREAK                shift, and go to state 51
    CONTINUE             shift, and go to state 52
    TRUE_TOKEN           shift, and go to state 53
    FALSE_TOKEN          shift, and go to state 54
    ENUM                 shift, and go to state 1
    LEFT_PAREN           shift, and go to state 55
    RIGHT_CURLY_BRACKET  shift, and go to state 206
    INC_OP               shift, and go to state 56
    DEC_OP               shift, and go to state 57
    NOT_OP               shift, and go to state 58

    $default  reduce using rule 20 ($@1)

    declarations          go to state 59
    $@1                   go to state 6
    bool_expression       go to state 60
    assign                go to state 61
    expression            go to state 62
    simpleExp             go to state 63
    andExp                go to state 64
    bitRelExp             go to state 65
    relExp                go to state 66
    bitshiftExp           go to state 67
    sumExp                go to state 68
    mulExp                go to state 69
    unaryExp              go to state 70
    value                 go to state 71
    if_statement          go to state 72
    while_statement       go to state 73
    for_statement         go to state 74
    do_statement          go to state 75
    switch_statement      go to state 76
    return_statement      go to state 77
    break_statement       go to state 78
    continue_statement    go to state 79
    expression_statement  go to state 80
    statement             go to state 138
    enum_statement        go to state 83
    func_call             go to state 84


State 198

   75 else_if: ELIF . LEFT_PAREN bool_expression RIGHT_PAREN tail

    LEFT_PAREN  shift, and go to state 207


State 199

   76 else_if: else_if . ELIF LEFT_PAREN bool_expression RIGHT_PAREN tail
   78 else_part: . ELSE tail
   79          | . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, IDENT, CONST_INT, CONST_FLOAT, CONST_CHAR, STRING_LITERAL, IF, WHILE, FOR, DO, SWITCH, CASE, DEFAULT, RETURN, BREAK, CONTINUE, TRUE_TOKEN, FALSE_TOKEN, ENUM, LEFT_PAREN, RIGHT_CURLY_BRACKET, INC_OP, DEC_OP, NOT_OP]
   80 if_statement: IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if . else_part

    ELSE  shift, and go to state 208
    ELIF  shift, and go to state 209

    $default  reduce using rule 79 (else_part)

    else_part  go to state 210


State 200

   84 for_statement: FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression . SEMICOLON expression RIGHT_PAREN tail_inloop

    SEMICOLON  shift, and go to state 211


State 201

   85 do_statement: DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN . SEMICOLON

    SEMICOLON  shift, and go to state 212


State 202

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   91 case: CASE . expression COLON statements BREAK SEMICOLON

    IDENT           shift, and go to state 104
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 60
    assign           go to state 61
    expression       go to state 213
    simpleExp        go to state 63
    andExp           go to state 64
    bitRelExp        go to state 65
    relExp           go to state 66
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 203

   86 switch_statement: SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases . RIGHT_CURLY_BRACKET
   88 cases: cases . case
   89      | cases . default
   90 default: . DEFAULT COLON statements
   91 case: . CASE expression COLON statements BREAK SEMICOLON

    CASE                 shift, and go to state 202
    DEFAULT              shift, and go to state 214
    RIGHT_CURLY_BRACKET  shift, and go to state 215

    default  go to state 216
    case     go to state 217


State 204

   87 cases: case .

    $default  reduce using rule 87 (cases)


State 205

  132 func_call: IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON .

    $default  reduce using rule 132 (func_call)


State 206

   23 tail: LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET .

    $default  reduce using rule 23 (tail)


State 207

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   75 else_if: ELIF LEFT_PAREN . bool_expression RIGHT_PAREN tail

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 218
    relExp           go to state 153
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 208

   23 tail: . LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET
   78 else_part: ELSE . tail

    LEFT_CURLY_BRACKET  shift, and go to state 190

    tail  go to state 219


State 209

   76 else_if: else_if ELIF . LEFT_PAREN bool_expression RIGHT_PAREN tail

    LEFT_PAREN  shift, and go to state 220


State 210

   80 if_statement: IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part .

    $default  reduce using rule 80 (if_statement)


State 211

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   84 for_statement: FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON . expression RIGHT_PAREN tail_inloop

    IDENT           shift, and go to state 104
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 60
    assign           go to state 61
    expression       go to state 221
    simpleExp        go to state 63
    andExp           go to state 64
    bitRelExp        go to state 65
    relExp           go to state 66
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 212

   85 do_statement: DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON .

    $default  reduce using rule 85 (do_statement)


State 213

   91 case: CASE expression . COLON statements BREAK SEMICOLON

    COLON  shift, and go to state 222


State 214

   90 default: DEFAULT . COLON statements

    COLON  shift, and go to state 223


State 215

   86 switch_statement: SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET .

    $default  reduce using rule 86 (switch_statement)


State 216

   89 cases: cases default .

    $default  reduce using rule 89 (cases)


State 217

   88 cases: cases case .

    $default  reduce using rule 88 (cases)


State 218

   75 else_if: ELIF LEFT_PAREN bool_expression . RIGHT_PAREN tail

    RIGHT_PAREN  shift, and go to state 224


State 219

   78 else_part: ELSE tail .

    $default  reduce using rule 78 (else_part)


State 220

   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   76 else_if: else_if ELIF LEFT_PAREN . bool_expression RIGHT_PAREN tail

    IDENT           shift, and go to state 151
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    bool_expression  go to state 225
    relExp           go to state 153
    bitshiftExp      go to state 67
    sumExp           go to state 68
    mulExp           go to state 69
    unaryExp         go to state 70
    value            go to state 71


State 221

   84 for_statement: FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression . RIGHT_PAREN tail_inloop

    RIGHT_PAREN  shift, and go to state 226


State 222

   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   80 if_statement: . IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part
   81 while_statement: . WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop
   84 for_statement: . FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop
   85 do_statement: . DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON
   86 switch_statement: . SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET
   91 case: CASE expression COLON . statements BREAK SEMICOLON
   94 return_statement: . RETURN return_val SEMICOLON
   95 break_statement: . BREAK SEMICOLON
   96 continue_statement: . CONTINUE SEMICOLON
   97 expression_statement: . expression SEMICOLON
   98 statements: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, IDENT, CONST_INT, CONST_FLOAT, CONST_CHAR, STRING_LITERAL, IF, WHILE, FOR, DO, SWITCH, RETURN, BREAK, CONTINUE, TRUE_TOKEN, FALSE_TOKEN, ENUM, LEFT_PAREN, INC_OP, DEC_OP, NOT_OP]
   99           | . statement
  100           | . statements statement
  101 statement: . if_statement
  102          | . while_statement
  103          | . for_statement
  104          | . do_statement
  105          | . switch_statement
  106          | . return_statement
  107          | . expression_statement
  108          | . declarations
  109          | . enum_statement
  110          | . func_call
  111          | . break_statement
  112          | . continue_statement
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON
  131 func_call: . IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | . IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    IDENT           shift, and go to state 40
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    IF              shift, and go to state 45
    WHILE           shift, and go to state 46
    FOR             shift, and go to state 47
    DO              shift, and go to state 48
    SWITCH          shift, and go to state 49
    RETURN          shift, and go to state 50
    BREAK           shift, and go to state 51
    CONTINUE        shift, and go to state 52
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    ENUM            shift, and go to state 1
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    INTEGER         reduce using rule 20 ($@1)
    INTEGER         [reduce using rule 98 (statements)]
    FLOAT           reduce using rule 20 ($@1)
    FLOAT           [reduce using rule 98 (statements)]
    DOUBLE          reduce using rule 20 ($@1)
    DOUBLE          [reduce using rule 98 (statements)]
    VOID            reduce using rule 20 ($@1)
    VOID            [reduce using rule 98 (statements)]
    BOOLEAN         reduce using rule 20 ($@1)
    BOOLEAN         [reduce using rule 98 (statements)]
    CHAR            reduce using rule 20 ($@1)
    CHAR            [reduce using rule 98 (statements)]
    CONST           reduce using rule 20 ($@1)
    CONST           [reduce using rule 98 (statements)]
    STR             reduce using rule 20 ($@1)
    STR             [reduce using rule 98 (statements)]
    IDENT           [reduce using rule 98 (statements)]
    CONST_INT       [reduce using rule 98 (statements)]
    CONST_FLOAT     [reduce using rule 98 (statements)]
    CONST_CHAR      [reduce using rule 98 (statements)]
    STRING_LITERAL  [reduce using rule 98 (statements)]
    IF              [reduce using rule 98 (statements)]
    WHILE           [reduce using rule 98 (statements)]
    FOR             [reduce using rule 98 (statements)]
    DO              [reduce using rule 98 (statements)]
    SWITCH          [reduce using rule 98 (statements)]
    RETURN          [reduce using rule 98 (statements)]
    BREAK           [reduce using rule 98 (statements)]
    CONTINUE        [reduce using rule 98 (statements)]
    TRUE_TOKEN      [reduce using rule 98 (statements)]
    FALSE_TOKEN     [reduce using rule 98 (statements)]
    ENUM            [reduce using rule 98 (statements)]
    LEFT_PAREN      [reduce using rule 98 (statements)]
    INC_OP          [reduce using rule 98 (statements)]
    DEC_OP          [reduce using rule 98 (statements)]
    NOT_OP          [reduce using rule 98 (statements)]
    $default        reduce using rule 20 ($@1)

    declarations          go to state 59
    $@1                   go to state 6
    bool_expression       go to state 60
    assign                go to state 61
    expression            go to state 62
    simpleExp             go to state 63
    andExp                go to state 64
    bitRelExp             go to state 65
    relExp                go to state 66
    bitshiftExp           go to state 67
    sumExp                go to state 68
    mulExp                go to state 69
    unaryExp              go to state 70
    value                 go to state 71
    if_statement          go to state 72
    while_statement       go to state 73
    for_statement         go to state 74
    do_statement          go to state 75
    switch_statement      go to state 76
    return_statement      go to state 77
    break_statement       go to state 78
    continue_statement    go to state 79
    expression_statement  go to state 80
    statements            go to state 227
    statement             go to state 82
    enum_statement        go to state 83
    func_call             go to state 84


State 223

   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   80 if_statement: . IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part
   81 while_statement: . WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop
   84 for_statement: . FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop
   85 do_statement: . DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON
   86 switch_statement: . SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET
   90 default: DEFAULT COLON . statements
   94 return_statement: . RETURN return_val SEMICOLON
   95 break_statement: . BREAK SEMICOLON
   96 continue_statement: . CONTINUE SEMICOLON
   97 expression_statement: . expression SEMICOLON
   98 statements: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, IDENT, CONST_INT, CONST_FLOAT, CONST_CHAR, STRING_LITERAL, IF, WHILE, FOR, DO, SWITCH, CASE, DEFAULT, RETURN, BREAK, CONTINUE, TRUE_TOKEN, FALSE_TOKEN, ENUM, LEFT_PAREN, RIGHT_CURLY_BRACKET, INC_OP, DEC_OP, NOT_OP]
   99           | . statement
  100           | . statements statement
  101 statement: . if_statement
  102          | . while_statement
  103          | . for_statement
  104          | . do_statement
  105          | . switch_statement
  106          | . return_statement
  107          | . expression_statement
  108          | . declarations
  109          | . enum_statement
  110          | . func_call
  111          | . break_statement
  112          | . continue_statement
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON
  131 func_call: . IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | . IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    IDENT           shift, and go to state 40
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    IF              shift, and go to state 45
    WHILE           shift, and go to state 46
    FOR             shift, and go to state 47
    DO              shift, and go to state 48
    SWITCH          shift, and go to state 49
    RETURN          shift, and go to state 50
    BREAK           shift, and go to state 51
    CONTINUE        shift, and go to state 52
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    ENUM            shift, and go to state 1
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    INTEGER              reduce using rule 20 ($@1)
    INTEGER              [reduce using rule 98 (statements)]
    FLOAT                reduce using rule 20 ($@1)
    FLOAT                [reduce using rule 98 (statements)]
    DOUBLE               reduce using rule 20 ($@1)
    DOUBLE               [reduce using rule 98 (statements)]
    VOID                 reduce using rule 20 ($@1)
    VOID                 [reduce using rule 98 (statements)]
    BOOLEAN              reduce using rule 20 ($@1)
    BOOLEAN              [reduce using rule 98 (statements)]
    CHAR                 reduce using rule 20 ($@1)
    CHAR                 [reduce using rule 98 (statements)]
    CONST                reduce using rule 20 ($@1)
    CONST                [reduce using rule 98 (statements)]
    STR                  reduce using rule 20 ($@1)
    STR                  [reduce using rule 98 (statements)]
    IDENT                [reduce using rule 98 (statements)]
    CONST_INT            [reduce using rule 98 (statements)]
    CONST_FLOAT          [reduce using rule 98 (statements)]
    CONST_CHAR           [reduce using rule 98 (statements)]
    STRING_LITERAL       [reduce using rule 98 (statements)]
    IF                   [reduce using rule 98 (statements)]
    WHILE                [reduce using rule 98 (statements)]
    FOR                  [reduce using rule 98 (statements)]
    DO                   [reduce using rule 98 (statements)]
    SWITCH               [reduce using rule 98 (statements)]
    CASE                 reduce using rule 98 (statements)
    DEFAULT              reduce using rule 98 (statements)
    RETURN               [reduce using rule 98 (statements)]
    BREAK                [reduce using rule 98 (statements)]
    CONTINUE             [reduce using rule 98 (statements)]
    TRUE_TOKEN           [reduce using rule 98 (statements)]
    FALSE_TOKEN          [reduce using rule 98 (statements)]
    ENUM                 [reduce using rule 98 (statements)]
    LEFT_PAREN           [reduce using rule 98 (statements)]
    RIGHT_CURLY_BRACKET  reduce using rule 98 (statements)
    INC_OP               [reduce using rule 98 (statements)]
    DEC_OP               [reduce using rule 98 (statements)]
    NOT_OP               [reduce using rule 98 (statements)]
    $default             reduce using rule 20 ($@1)

    declarations          go to state 59
    $@1                   go to state 6
    bool_expression       go to state 60
    assign                go to state 61
    expression            go to state 62
    simpleExp             go to state 63
    andExp                go to state 64
    bitRelExp             go to state 65
    relExp                go to state 66
    bitshiftExp           go to state 67
    sumExp                go to state 68
    mulExp                go to state 69
    unaryExp              go to state 70
    value                 go to state 71
    if_statement          go to state 72
    while_statement       go to state 73
    for_statement         go to state 74
    do_statement          go to state 75
    switch_statement      go to state 76
    return_statement      go to state 77
    break_statement       go to state 78
    continue_statement    go to state 79
    expression_statement  go to state 80
    statements            go to state 228
    statement             go to state 82
    enum_statement        go to state 83
    func_call             go to state 84


State 224

   23 tail: . LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET
   75 else_if: ELIF LEFT_PAREN bool_expression RIGHT_PAREN . tail

    LEFT_CURLY_BRACKET  shift, and go to state 190

    tail  go to state 229


State 225

   76 else_if: else_if ELIF LEFT_PAREN bool_expression . RIGHT_PAREN tail

    RIGHT_PAREN  shift, and go to state 230


State 226

   24 tail_inloop: . LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET
   84 for_statement: FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN . tail_inloop

    LEFT_CURLY_BRACKET  shift, and go to state 101

    tail_inloop  go to state 231


State 227

   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   80 if_statement: . IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part
   81 while_statement: . WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop
   84 for_statement: . FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop
   85 do_statement: . DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON
   86 switch_statement: . SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET
   91 case: CASE expression COLON statements . BREAK SEMICOLON
   94 return_statement: . RETURN return_val SEMICOLON
   95 break_statement: . BREAK SEMICOLON
   96 continue_statement: . CONTINUE SEMICOLON
   97 expression_statement: . expression SEMICOLON
  100 statements: statements . statement
  101 statement: . if_statement
  102          | . while_statement
  103          | . for_statement
  104          | . do_statement
  105          | . switch_statement
  106          | . return_statement
  107          | . expression_statement
  108          | . declarations
  109          | . enum_statement
  110          | . func_call
  111          | . break_statement
  112          | . continue_statement
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON
  131 func_call: . IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | . IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    IDENT           shift, and go to state 40
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    IF              shift, and go to state 45
    WHILE           shift, and go to state 46
    FOR             shift, and go to state 47
    DO              shift, and go to state 48
    SWITCH          shift, and go to state 49
    RETURN          shift, and go to state 50
    BREAK           shift, and go to state 232
    CONTINUE        shift, and go to state 52
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    ENUM            shift, and go to state 1
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    $default  reduce using rule 20 ($@1)

    declarations          go to state 59
    $@1                   go to state 6
    bool_expression       go to state 60
    assign                go to state 61
    expression            go to state 62
    simpleExp             go to state 63
    andExp                go to state 64
    bitRelExp             go to state 65
    relExp                go to state 66
    bitshiftExp           go to state 67
    sumExp                go to state 68
    mulExp                go to state 69
    unaryExp              go to state 70
    value                 go to state 71
    if_statement          go to state 72
    while_statement       go to state 73
    for_statement         go to state 74
    do_statement          go to state 75
    switch_statement      go to state 76
    return_statement      go to state 77
    break_statement       go to state 78
    continue_statement    go to state 79
    expression_statement  go to state 80
    statement             go to state 138
    enum_statement        go to state 83
    func_call             go to state 84


State 228

   20 $@1: . %empty  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR]
   21 declarations: . $@1 declaration
   22             | . declarations declaration
   25 bool_expression: . relExp
   26                | . TRUE_TOKEN
   27                | . FALSE_TOKEN
   28 assign: . IDENT ASSIGN_OP expression
   29 expression: . assign
   30           | . IDENT INC_OP
   31           | . IDENT DEC_OP
   32           | . simpleExp
   33           | . IDENT
   34           | . bool_expression
   35 simpleExp: . simpleExp OR_OP andExp
   36          | . andExp
   37 andExp: . andExp AND_OP
   38       | . bitRelExp
   39 bitRelExp: . bitRelExp BIT_OR_OP relExp
   40          | . bitRelExp AND relExp
   41          | . bitRelExp BIT_XOR_OP relExp
   42          | . relExp
   51 relExp: . relExp op bitshiftExp
   52       | . bitshiftExp
   53 bitshiftExp: . bitshiftExp BIT_LSHIFT_OP sumExp
   54            | . bitshiftExp BIT_RSHIFT_OP sumExp
   55            | . sumExp
   61 sumExp: . sumExp pls_min mulExp
   62       | . mulExp
   63 mulExp: . mulExp mul_div unaryExp
   64       | . unaryExp
   65 unaryExp: . INC_OP IDENT
   66         | . DEC_OP IDENT
   67         | . NOT_OP IDENT
   68         | . IDENT
   69         | . value
   70         | . LEFT_PAREN expression RIGHT_PAREN
   71 value: . CONST_INT
   72      | . CONST_FLOAT
   73      | . CONST_CHAR
   74      | . STRING_LITERAL
   80 if_statement: . IF LEFT_PAREN bool_expression RIGHT_PAREN tail else_if else_part
   81 while_statement: . WHILE LEFT_PAREN bool_expression RIGHT_PAREN tail_inloop
   84 for_statement: . FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop
   85 do_statement: . DO tail_inloop UNTIL LEFT_PAREN bool_expression RIGHT_PAREN SEMICOLON
   86 switch_statement: . SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_CURLY_BRACKET cases RIGHT_CURLY_BRACKET
   90 default: DEFAULT COLON statements .  [CASE, DEFAULT, RIGHT_CURLY_BRACKET]
   94 return_statement: . RETURN return_val SEMICOLON
   95 break_statement: . BREAK SEMICOLON
   96 continue_statement: . CONTINUE SEMICOLON
   97 expression_statement: . expression SEMICOLON
  100 statements: statements . statement
  101 statement: . if_statement
  102          | . while_statement
  103          | . for_statement
  104          | . do_statement
  105          | . switch_statement
  106          | . return_statement
  107          | . expression_statement
  108          | . declarations
  109          | . enum_statement
  110          | . func_call
  111          | . break_statement
  112          | . continue_statement
  126 enum_statement: . ENUM IDENT LEFT_CURLY_BRACKET enum_list RIGHT_CURLY_BRACKET SEMICOLON
  131 func_call: . IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON
  132          | . IDENT ASSIGN_OP IDENT LEFT_PAREN arguments RIGHT_PAREN SEMICOLON

    IDENT           shift, and go to state 40
    CONST_INT       shift, and go to state 41
    CONST_FLOAT     shift, and go to state 42
    CONST_CHAR      shift, and go to state 43
    STRING_LITERAL  shift, and go to state 44
    IF              shift, and go to state 45
    WHILE           shift, and go to state 46
    FOR             shift, and go to state 47
    DO              shift, and go to state 48
    SWITCH          shift, and go to state 49
    RETURN          shift, and go to state 50
    BREAK           shift, and go to state 51
    CONTINUE        shift, and go to state 52
    TRUE_TOKEN      shift, and go to state 53
    FALSE_TOKEN     shift, and go to state 54
    ENUM            shift, and go to state 1
    LEFT_PAREN      shift, and go to state 55
    INC_OP          shift, and go to state 56
    DEC_OP          shift, and go to state 57
    NOT_OP          shift, and go to state 58

    CASE                 reduce using rule 90 (default)
    DEFAULT              reduce using rule 90 (default)
    RIGHT_CURLY_BRACKET  reduce using rule 90 (default)
    $default             reduce using rule 20 ($@1)

    declarations          go to state 59
    $@1                   go to state 6
    bool_expression       go to state 60
    assign                go to state 61
    expression            go to state 62
    simpleExp             go to state 63
    andExp                go to state 64
    bitRelExp             go to state 65
    relExp                go to state 66
    bitshiftExp           go to state 67
    sumExp                go to state 68
    mulExp                go to state 69
    unaryExp              go to state 70
    value                 go to state 71
    if_statement          go to state 72
    while_statement       go to state 73
    for_statement         go to state 74
    do_statement          go to state 75
    switch_statement      go to state 76
    return_statement      go to state 77
    break_statement       go to state 78
    continue_statement    go to state 79
    expression_statement  go to state 80
    statement             go to state 138
    enum_statement        go to state 83
    func_call             go to state 84


State 229

   75 else_if: ELIF LEFT_PAREN bool_expression RIGHT_PAREN tail .

    $default  reduce using rule 75 (else_if)


State 230

   23 tail: . LEFT_CURLY_BRACKET statements RIGHT_CURLY_BRACKET
   76 else_if: else_if ELIF LEFT_PAREN bool_expression RIGHT_PAREN . tail

    LEFT_CURLY_BRACKET  shift, and go to state 190

    tail  go to state 233


State 231

   84 for_statement: FOR LEFT_PAREN optional_type assign SEMICOLON bool_expression SEMICOLON expression RIGHT_PAREN tail_inloop .

    $default  reduce using rule 84 (for_statement)


State 232

   91 case: CASE expression COLON statements BREAK . SEMICOLON
   95 break_statement: BREAK . SEMICOLON

    SEMICOLON  shift, and go to state 234


State 233

   76 else_if: else_if ELIF LEFT_PAREN bool_expression RIGHT_PAREN tail .

    $default  reduce using rule 76 (else_if)


State 234

   91 case: CASE expression COLON statements BREAK SEMICOLON .  [CASE, DEFAULT, RIGHT_CURLY_BRACKET]
   95 break_statement: BREAK SEMICOLON .  [INTEGER, FLOAT, DOUBLE, VOID, BOOLEAN, CHAR, CONST, STR, IDENT, CONST_INT, CONST_FLOAT, CONST_CHAR, STRING_LITERAL, IF, WHILE, FOR, DO, SWITCH, RETURN, BREAK, CONTINUE, TRUE_TOKEN, FALSE_TOKEN, ENUM, LEFT_PAREN, INC_OP, DEC_OP, NOT_OP]

    CASE                 reduce using rule 91 (case)
    DEFAULT              reduce using rule 91 (case)
    RIGHT_CURLY_BRACKET  reduce using rule 91 (case)
    $default             reduce using rule 95 (break_statement)
